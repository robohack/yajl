<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<!-- This HTML file generated by cxref (version 1.6d). -->
<!-- cxref program (c) Andrew M. Bishop 1995-2011. -->

<!--
Cxref: cxref -warn-all -xref-all -block-comments -O/work/woods/f-yajl/build/work/woods/f-yajl/doc/html -Nyajl -html -html-src -I/work/woods/f-yajl/src -I/work/woods/f-yajl/build/work/woods/f-yajl/./src-CPP "cc -E -CC -x c" src/yajl_lex.c
CPP  : cc -E -CC -x c -Isrc -Ibuild/work/woods/f-yajl/./src
-->

<HTML>

<HEAD>
<TITLE>Source File src/yajl_lex.c</TITLE>
<LINK rel="stylesheet" href="../cxref.css" type="text/css">
</HEAD>

<BODY>

<pre>
<a name="line1">1    |</a> /*
<a name="line2">2    |</a>  * Copyright (c) 2007-2014, Lloyd Hilaiel &lt;me@lloyd.io&gt;
<a name="line3">3    |</a>  *
<a name="line4">4    |</a>  * Permission to use, copy, modify, and/or distribute this software for any
<a name="line5">5    |</a>  * purpose with or without fee is hereby granted, provided that the above
<a name="line6">6    |</a>  * copyright notice and this permission notice appear in all copies.
<a name="line7">7    |</a>  *
<a name="line8">8    |</a>  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
<a name="line9">9    |</a>  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
<a name="line10">10   |</a>  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
<a name="line11">11   |</a>  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
<a name="line12">12   |</a>  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
<a name="line13">13   |</a>  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
<a name="line14">14   |</a>  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
<a name="line15">15   |</a>  */
<a name="line16">16   |</a> 
<a name="line17">17   |</a> /**
<a name="line18">18   |</a>  * A JSON text lexical analyzer.
<a name="line19">19   |</a>  *
<a name="line20">20   |</a>  * The implementation.
<a name="line21">21   |</a>  **/
<a name="line22">22   |</a> 
<a name="line23">23   |</a> #include "yajl_lex.h"
<a name="line24">24   |</a> #include "yajl_buf.h"
<a name="line25">25   |</a> 
<a name="line26">26   |</a> #include &lt;stdlib.h&gt;
<a name="line27">27   |</a> #include &lt;stdio.h&gt;
<a name="line28">28   |</a> #include &lt;assert.h&gt;
<a name="line29">29   |</a> #include &lt;string.h&gt;
<a name="line30">30   |</a> 
<a name="line31">31   |</a> #ifdef YAJL_LEXER_DEBUG
<a name="line32">32   |</a> static const char *
<a name="line33">33   |</a> tokToStr(yajl_tok tok)
<a name="line34">34   |</a> {
<a name="line35">35   |</a>     switch (tok) {
<a name="line36">36   |</a>         case yajl_tok_bool: return "bool";
<a name="line37">37   |</a>         case yajl_tok_colon: return "colon";
<a name="line38">38   |</a>         case yajl_tok_comma: return "comma";
<a name="line39">39   |</a>         case yajl_tok_eof: return "eof";
<a name="line40">40   |</a>         case yajl_tok_error: return "error";
<a name="line41">41   |</a>         case yajl_tok_left_brace: return "brace";
<a name="line42">42   |</a>         case yajl_tok_left_bracket: return "bracket";
<a name="line43">43   |</a>         case yajl_tok_null: return "null";
<a name="line44">44   |</a>         case yajl_tok_integer: return "integer";
<a name="line45">45   |</a>         case yajl_tok_double: return "double";
<a name="line46">46   |</a>         case yajl_tok_right_brace: return "brace";
<a name="line47">47   |</a>         case yajl_tok_right_bracket: return "bracket";
<a name="line48">48   |</a>         case yajl_tok_string: return "string";
<a name="line49">49   |</a>         case yajl_tok_string_with_escapes: return "string_with_escapes";
<a name="line50">50   |</a>     }
<a name="line51">51   |</a>     return "unknown";
<a name="line52">52   |</a> }
<a name="line53">53   |</a> #endif
<a name="line54">54   |</a> 
<a name="line55">55   |</a> /*
<a name="line56">56   |</a>  * Impact of the stream parsing feature on the lexer:
<a name="line57">57   |</a>  *
<a name="line58">58   |</a>  * YAJL supports parsing of streams.  That is, the ability to parse the first
<a name="line59">59   |</a>  * bits of a chunk of JSON before the last bits are available (still on
<a name="line60">60   |</a>  * the network or disk).  This makes the lexer more complex.  The
<a name="line61">61   |</a>  * responsibility of the lexer is to handle transparently the case where
<a name="line62">62   |</a>  * a chunk boundary falls in the middle of a token.  This is
<a name="line63">63   |</a>  * accomplished is via a buffer and a character reading abstraction.
<a name="line64">64   |</a>  *
<a name="line65">65   |</a>  * Overview of implementation
<a name="line66">66   |</a>  *
<a name="line67">67   |</a>  * When we lex to end of input string before end of token is hit, we
<a name="line68">68   |</a>  * copy all of the input text composing the token into our lexBuf.
<a name="line69">69   |</a>  *
<a name="line70">70   |</a>  * Every time we read a character, we do so through the readChar function.
<a name="line71">71   |</a>  * readChar's responsibility is to handle pulling all chars from the buffer
<a name="line72">72   |</a>  * before pulling chars from input text
<a name="line73">73   |</a>  */
<a name="line74">74   |</a> 
<a name="line75">75   |</a> /*+ the (private) lexer context +*/
<a name="line76">76   |</a> struct yajl_lexer_t {
<a name="line77">77   |</a>     /*+ the current line count +*/
<a name="line78">78   |</a>     size_t lineOff;
<a name="line79">79   |</a>     /* the current character offset into the current line (i.e. since the last '\r' or '\n') */
<a name="line80">80   |</a>     size_t charOff;
<a name="line81">81   |</a> 
<a name="line82">82   |</a>     /*+ error +*/
<a name="line83">83   |</a>     yajl_lex_error error;
<a name="line84">84   |</a> 
<a name="line85">85   |</a>     /*+ a input buffer to handle the case where a token is spread over
<a name="line86">86   |</a>      * multiple chunks +*/
<a name="line87">87   |</a>     yajl_buf buf;
<a name="line88">88   |</a> 
<a name="line89">89   |</a>     /*+ in the case where we have data in the lexBuf, bufOff holds
<a name="line90">90   |</a>      * the current offset into the lexBuf. +*/
<a name="line91">91   |</a>     size_t bufOff;
<a name="line92">92   |</a> 
<a name="line93">93   |</a>     /*+ are we using the lex buf? +*/
<a name="line94">94   |</a>     /* bool */ int bufInUse;
<a name="line95">95   |</a> 
<a name="line96">96   |</a>     /*+ shall we allow comments? +*/
<a name="line97">97   |</a>     /* bool */ int allowComments;
<a name="line98">98   |</a> 
<a name="line99">99   |</a>     /*+ shall we validate utf8 inside strings? +*/
<a name="line100">100  |</a>     /* bool */ int validateUTF8;
<a name="line101">101  |</a> 
<a name="line102">102  |</a>     /* the allocator functions being used by this lexer */
<a name="line103">103  |</a>     yajl_alloc_funcs * alloc;
<a name="line104">104  |</a> };
<a name="line105">105  |</a> 
<a name="line106">106  |</a> #define readChar(lxr, txt, off)                      \
<a name="line107">107  |</a>     (((lxr)-&gt;bufInUse &amp;&amp; yajl_buf_len((lxr)-&gt;buf) &amp;&amp; lxr-&gt;bufOff &lt; yajl_buf_len((lxr)-&gt;buf)) ? \
<a name="line108">108  |</a>      (*((const unsigned char *) yajl_buf_data((lxr)-&gt;buf) + ((lxr)-&gt;bufOff)++)) : \
<a name="line109">109  |</a>      ((txt)[(*(off))++]))
<a name="line110">110  |</a> 
<a name="line111">111  |</a> #define unreadChar(lxr, off) ((*(off) &gt; 0) ? (*(off))-- : ((lxr)-&gt;bufOff--))
<a name="line112">112  |</a> 
<a name="line113">113  |</a> /*+
<a name="line114">114  |</a>  * allocate a lexer context
<a name="line115">115  |</a>  *
<a name="line116">116  |</a>  * Returns a lexer context object that must be passed to calls to
<a name="line117">117  |</a>  * yajl_lex_lex(), etc., and which must be passed to yajl_lex_free() when lexing
<a name="line118">118  |</a>  * is complete (successfully or not).
<a name="line119">119  |</a>  +*/
<a name="line120">120  |</a> yajl_lexer
<a name="line121">121  |</a> yajl_lex_alloc(yajl_alloc_funcs * alloc, /*+ allocator functions, e.g. from yajl_set_default_alloc_funcs() +*/
<a name="line122">122  |</a>                /* bool */ int allowComments, /*+ should this lexer handle comments embedded in the JSON text? +*/
<a name="line123">123  |</a>                /* bool */ int validateUTF8)  /*+ should this lexer validate UTF8 characters? +*/
<a name="line124">124  |</a> {
<a name="line125">125  |</a>     yajl_lexer lxr = (yajl_lexer) YA_MALLOC(alloc, sizeof(struct yajl_lexer_t));
<a name="line126">126  |</a>     memset((void *) lxr, 0, sizeof(struct yajl_lexer_t));
<a name="line127">127  |</a>     lxr-&gt;buf = yajl_buf_alloc(alloc);
<a name="line128">128  |</a>     lxr-&gt;allowComments = allowComments;
<a name="line129">129  |</a>     lxr-&gt;validateUTF8 = validateUTF8;
<a name="line130">130  |</a>     lxr-&gt;alloc = alloc;
<a name="line131">131  |</a>     return lxr;
<a name="line132">132  |</a> }
<a name="line133">133  |</a> 
<a name="line134">134  |</a> /*+ free a lexer context +*/
<a name="line135">135  |</a> void
<a name="line136">136  |</a> yajl_lex_free(yajl_lexer lxr)           /*+ the lexer context to free +*/
<a name="line137">137  |</a> {
<a name="line138">138  |</a>     yajl_buf_free(lxr-&gt;buf);
<a name="line139">139  |</a>     YA_FREE(lxr-&gt;alloc, lxr);
<a name="line140">140  |</a>     return;
<a name="line141">141  |</a> }
<a name="line142">142  |</a> 
<a name="line143">143  |</a> #define VEC 0x01
<a name="line144">144  |</a> #define IJC 0x02
<a name="line145">145  |</a> #define VHC 0x04
<a name="line146">146  |</a> #define NFP 0x08
<a name="line147">147  |</a> #define NUC 0x10
<a name="line148">148  |</a> 
<a name="line149">149  |</a> /*+
<a name="line150">150  |</a>  * a lookup table which lets us quickly determine three things:
<a name="line151">151  |</a>  *
<a name="line152">152  |</a>  * VEC - valid escaped control char
<a name="line153">153  |</a>  *
<a name="line154">154  |</a>  * IJC - invalid json char
<a name="line155">155  |</a>  *
<a name="line156">156  |</a>  * VHC - valid hex char
<a name="line157">157  |</a>  *
<a name="line158">158  |</a>  * NFP - needs further processing (from a string scanning perspective)
<a name="line159">159  |</a>  *
<a name="line160">160  |</a>  * NUC - needs utf8 checking when enabled (from a string scanning perspective)
<a name="line161">161  |</a>  *
<a name="line162">162  |</a>  * note.  the solidus '/' may be escaped or not.
<a name="line163">163  |</a>  +*/
<a name="line164">164  |</a> static const char charLookupTable[256] =
<a name="line165">165  |</a> {
<a name="line166">166  |</a> /*00*/ IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    ,
<a name="line167">167  |</a> /*08*/ IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    ,
<a name="line168">168  |</a> /*10*/ IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    ,
<a name="line169">169  |</a> /*18*/ IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    , IJC    ,
<a name="line170">170  |</a> 
<a name="line171">171  |</a> /*20*/ 0      , 0      , NFP|VEC|IJC, 0      , 0      , 0      , 0      , 0      ,
<a name="line172">172  |</a> /*28*/ 0      , 0      , 0      , 0      , 0      , 0      , 0      , VEC    ,
<a name="line173">173  |</a> /*30*/ VHC    , VHC    , VHC    , VHC    , VHC    , VHC    , VHC    , VHC    ,
<a name="line174">174  |</a> /*38*/ VHC    , VHC    , 0      , 0      , 0      , 0      , 0      , 0      ,
<a name="line175">175  |</a> 
<a name="line176">176  |</a> /*40*/ 0      , VHC    , VHC    , VHC    , VHC    , VHC    , VHC    , 0      ,
<a name="line177">177  |</a> /*48*/ 0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      ,
<a name="line178">178  |</a> /*50*/ 0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      ,
<a name="line179">179  |</a> /*58*/ 0      , 0      , 0      , 0      , NFP|VEC|IJC, 0      , 0      , 0      ,
<a name="line180">180  |</a> 
<a name="line181">181  |</a> /*60*/ 0      , VHC    , VEC|VHC, VHC    , VHC    , VHC    , VEC|VHC, 0      ,
<a name="line182">182  |</a> /*68*/ 0      , 0      , 0      , 0      , 0      , 0      , VEC    , 0      ,
<a name="line183">183  |</a> /*70*/ 0      , 0      , VEC    , 0      , VEC    , 0      , 0      , 0      ,
<a name="line184">184  |</a> /*78*/ 0      , 0      , 0      , 0      , 0      , 0      , 0      , 0      ,
<a name="line185">185  |</a> 
<a name="line186">186  |</a>        NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    ,
<a name="line187">187  |</a>        NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    ,
<a name="line188">188  |</a>        NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    ,
<a name="line189">189  |</a>        NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    ,
<a name="line190">190  |</a> 
<a name="line191">191  |</a>        NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    ,
<a name="line192">192  |</a>        NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    ,
<a name="line193">193  |</a>        NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    ,
<a name="line194">194  |</a>        NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    ,
<a name="line195">195  |</a> 
<a name="line196">196  |</a>        NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    ,
<a name="line197">197  |</a>        NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    ,
<a name="line198">198  |</a>        NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    ,
<a name="line199">199  |</a>        NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    ,
<a name="line200">200  |</a> 
<a name="line201">201  |</a>        NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    ,
<a name="line202">202  |</a>        NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    ,
<a name="line203">203  |</a>        NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    ,
<a name="line204">204  |</a>        NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC    , NUC
<a name="line205">205  |</a> };
<a name="line206">206  |</a> 
<a name="line207">207  |</a> #define UTF8_CHECK_EOF if (*offset &gt;= jsonTextLen) { return yajl_tok_eof; }
<a name="line208">208  |</a> 
<a name="line209">209  |</a> /*+
<a name="line210">210  |</a>  *  process a variable length utf8 encoded codepoint.
<a name="line211">211  |</a>  *
<a name="line212">212  |</a>  *  returns:
<a name="line213">213  |</a>  *
<a name="line214">214  |</a>  *    yajl_tok_string - if valid utf8 char was parsed and offset was
<a name="line215">215  |</a>  *                      advanced
<a name="line216">216  |</a>  *
<a name="line217">217  |</a>  *    yajl_tok_eof - if end of input was hit before validation could
<a name="line218">218  |</a>  *                   complete
<a name="line219">219  |</a>  *
<a name="line220">220  |</a>  *    yajl_tok_error - if invalid utf8 was encountered
<a name="line221">221  |</a>  *
<a name="line222">222  |</a>  *  NOTE: on error the offset will point to the first char of the
<a name="line223">223  |</a>  *  invalid utf8
<a name="line224">224  |</a>  +*/
<a name="line225">225  |</a> static yajl_tok
<a name="line226">226  |</a> yajl_lex_utf8_char(yajl_lexer lexer,
<a name="line227">227  |</a>                    const unsigned char * jsonText,
<a name="line228">228  |</a>                    size_t jsonTextLen,
<a name="line229">229  |</a>                    size_t * offset,
<a name="line230">230  |</a>                    unsigned int curChar)
<a name="line231">231  |</a> {
<a name="line232">232  |</a>     if (curChar &lt;= 0x7f) {
<a name="line233">233  |</a>         /* single byte */
<a name="line234">234  |</a>         return yajl_tok_string;
<a name="line235">235  |</a>     } else if ((curChar &gt;&gt; 5) == 0x6) {
<a name="line236">236  |</a>         /* two byte */
<a name="line237">237  |</a>         UTF8_CHECK_EOF;
<a name="line238">238  |</a>         curChar = readChar(lexer, jsonText, offset);
<a name="line239">239  |</a>         if ((curChar &gt;&gt; 6) == 0x2) return yajl_tok_string;
<a name="line240">240  |</a>     } else if ((curChar &gt;&gt; 4) == 0x0e) {
<a name="line241">241  |</a>         /* three byte */
<a name="line242">242  |</a>         UTF8_CHECK_EOF;
<a name="line243">243  |</a>         curChar = readChar(lexer, jsonText, offset);
<a name="line244">244  |</a>         if ((curChar &gt;&gt; 6) == 0x2) {
<a name="line245">245  |</a>             UTF8_CHECK_EOF;
<a name="line246">246  |</a>             curChar = readChar(lexer, jsonText, offset);
<a name="line247">247  |</a>             if ((curChar &gt;&gt; 6) == 0x2) return yajl_tok_string;
<a name="line248">248  |</a>         }
<a name="line249">249  |</a>     } else if ((curChar &gt;&gt; 3) == 0x1e) {
<a name="line250">250  |</a>         /* four byte */
<a name="line251">251  |</a>         UTF8_CHECK_EOF;
<a name="line252">252  |</a>         curChar = readChar(lexer, jsonText, offset);
<a name="line253">253  |</a>         if ((curChar &gt;&gt; 6) == 0x2) {
<a name="line254">254  |</a>             UTF8_CHECK_EOF;
<a name="line255">255  |</a>             curChar = readChar(lexer, jsonText, offset);
<a name="line256">256  |</a>             if ((curChar &gt;&gt; 6) == 0x2) {
<a name="line257">257  |</a>                 UTF8_CHECK_EOF;
<a name="line258">258  |</a>                 curChar = readChar(lexer, jsonText, offset);
<a name="line259">259  |</a>                 if ((curChar &gt;&gt; 6) == 0x2) return yajl_tok_string;
<a name="line260">260  |</a>             }
<a name="line261">261  |</a>         }
<a name="line262">262  |</a>     }
<a name="line263">263  |</a> 
<a name="line264">264  |</a>     return yajl_tok_error;
<a name="line265">265  |</a> }
<a name="line266">266  |</a> 
<a name="line267">267  |</a> #define STR_CHECK_EOF \
<a name="line268">268  |</a> if (*offset &gt;= jsonTextLen) { \
<a name="line269">269  |</a>    tok = yajl_tok_eof; \
<a name="line270">270  |</a>    goto finish_string_lex; \
<a name="line271">271  |</a> }
<a name="line272">272  |</a> 
<a name="line273">273  |</a> /*+
<a name="line274">274  |</a>  *  scan a string for interesting characters that might need further
<a name="line275">275  |</a>  *  review.
<a name="line276">276  |</a>  *
<a name="line277">277  |</a>  *  returns the number of chars that are uninteresting and can be skipped.
<a name="line278">278  |</a>  *
<a name="line279">279  |</a>  * (lth) hi world, any thoughts on how to make this routine faster?
<a name="line280">280  |</a>  +*/
<a name="line281">281  |</a> static size_t
<a name="line282">282  |</a> yajl_string_scan(const unsigned char * buf, size_t len, /* bool */ int utf8check)
<a name="line283">283  |</a> {
<a name="line284">284  |</a>     unsigned char mask = IJC|NFP|(utf8check ? NUC : 0);
<a name="line285">285  |</a>     size_t skip = 0;
<a name="line286">286  |</a>     while (skip &lt; len &amp;&amp; !(charLookupTable[*buf] &amp; mask))
<a name="line287">287  |</a>     {
<a name="line288">288  |</a>         skip++;
<a name="line289">289  |</a>         buf++;
<a name="line290">290  |</a>     }
<a name="line291">291  |</a>     return skip;
<a name="line292">292  |</a> }
<a name="line293">293  |</a> 
<a name="line294">294  |</a> /*+
<a name="line295">295  |</a>  * lex a string.
<a name="line296">296  |</a>  *
<a name="line297">297  |</a>  * a token is returned which has the following meanings:
<a name="line298">298  |</a>  *
<a name="line299">299  |</a>  * yajl_tok_string: lex of string was successful.  offset points to
<a name="line300">300  |</a>  *                  terminating '"'.
<a name="line301">301  |</a>  *
<a name="line302">302  |</a>  * yajl_tok_eof: end of text was encountered before we could complete
<a name="line303">303  |</a>  *               the lex.
<a name="line304">304  |</a>  *
<a name="line305">305  |</a>  * yajl_tok_error: embedded in the string were unallowable chars.  offset
<a name="line306">306  |</a>  *               points to the offending char
<a name="line307">307  |</a>  +*/
<a name="line308">308  |</a> static yajl_tok
<a name="line309">309  |</a> yajl_lex_string(yajl_lexer lexer,       /*+ the current lexer context +*/
<a name="line310">310  |</a>                 const unsigned char * jsonText, /*+ a pointer to the beginning of the JSON text +*/
<a name="line311">311  |</a>                 size_t jsonTextLen,             /*+ length of the JSON text +*/
<a name="line312">312  |</a>                 size_t * offset)                /*+ offset of the string to be lexed +*/
<a name="line313">313  |</a> {
<a name="line314">314  |</a>     yajl_tok tok = yajl_tok_error;
<a name="line315">315  |</a>     int hasEscapes = 0;
<a name="line316">316  |</a> 
<a name="line317">317  |</a>     for (;;) {
<a name="line318">318  |</a>         unsigned char curChar;
<a name="line319">319  |</a> 
<a name="line320">320  |</a>         /* now jump into a faster scanning routine to skip as much
<a name="line321">321  |</a>          * of the buffers as possible */
<a name="line322">322  |</a>         {
<a name="line323">323  |</a>             const unsigned char * p;
<a name="line324">324  |</a>             size_t len;
<a name="line325">325  |</a> 
<a name="line326">326  |</a>             if ((lexer-&gt;bufInUse &amp;&amp; yajl_buf_len(lexer-&gt;buf) &amp;&amp;
<a name="line327">327  |</a>                  lexer-&gt;bufOff &lt; yajl_buf_len(lexer-&gt;buf)))
<a name="line328">328  |</a>             {
<a name="line329">329  |</a>                 p = ((const unsigned char *) yajl_buf_data(lexer-&gt;buf) +
<a name="line330">330  |</a>                      (lexer-&gt;bufOff));
<a name="line331">331  |</a>                 len = yajl_buf_len(lexer-&gt;buf) - lexer-&gt;bufOff;
<a name="line332">332  |</a>                 lexer-&gt;bufOff += yajl_string_scan(p, len, lexer-&gt;validateUTF8);
<a name="line333">333  |</a>             }
<a name="line334">334  |</a>             else if (*offset &lt; jsonTextLen)
<a name="line335">335  |</a>             {
<a name="line336">336  |</a>                 p = jsonText + *offset;
<a name="line337">337  |</a>                 len = jsonTextLen - *offset;
<a name="line338">338  |</a>                 *offset += yajl_string_scan(p, len, lexer-&gt;validateUTF8);
<a name="line339">339  |</a>             }
<a name="line340">340  |</a>         }
<a name="line341">341  |</a> 
<a name="line342">342  |</a>         STR_CHECK_EOF;
<a name="line343">343  |</a> 
<a name="line344">344  |</a>         curChar = readChar(lexer, jsonText, offset);
<a name="line345">345  |</a> 
<a name="line346">346  |</a>         /* quote terminates */
<a name="line347">347  |</a>         if (curChar == '"') {
<a name="line348">348  |</a>             tok = yajl_tok_string;
<a name="line349">349  |</a>             break;
<a name="line350">350  |</a>         }
<a name="line351">351  |</a>         /* backslash escapes a set of control chars, */
<a name="line352">352  |</a>         else if (curChar == '\\') {
<a name="line353">353  |</a>             hasEscapes = 1;
<a name="line354">354  |</a>             STR_CHECK_EOF;
<a name="line355">355  |</a> 
<a name="line356">356  |</a>             /* special case \u */
<a name="line357">357  |</a>             curChar = readChar(lexer, jsonText, offset);
<a name="line358">358  |</a>             if (curChar == 'u') {
<a name="line359">359  |</a>                 unsigned int i = 0;
<a name="line360">360  |</a> 
<a name="line361">361  |</a>                 for (i=0;i&lt;4;i++) {
<a name="line362">362  |</a>                     STR_CHECK_EOF;
<a name="line363">363  |</a>                     curChar = readChar(lexer, jsonText, offset);
<a name="line364">364  |</a>                     if (!(charLookupTable[curChar] &amp; VHC)) {
<a name="line365">365  |</a>                         /* back up to offending char */
<a name="line366">366  |</a>                         unreadChar(lexer, offset);
<a name="line367">367  |</a>                         lexer-&gt;error = yajl_lex_string_invalid_hex_char;
<a name="line368">368  |</a>                         goto finish_string_lex;
<a name="line369">369  |</a>                     }
<a name="line370">370  |</a>                 }
<a name="line371">371  |</a>             } else if (!(charLookupTable[curChar] &amp; VEC)) {
<a name="line372">372  |</a>                 /* back up to offending char */
<a name="line373">373  |</a>                 unreadChar(lexer, offset);
<a name="line374">374  |</a>                 lexer-&gt;error = yajl_lex_string_invalid_escaped_char;
<a name="line375">375  |</a>                 goto finish_string_lex;
<a name="line376">376  |</a>             }
<a name="line377">377  |</a>         }
<a name="line378">378  |</a>         /* when not validating UTF8 it's a simple table lookup to determine
<a name="line379">379  |</a>          * if the present character is invalid */
<a name="line380">380  |</a>         else if(charLookupTable[curChar] &amp; IJC) {
<a name="line381">381  |</a>             /* back up to offending char */
<a name="line382">382  |</a>             unreadChar(lexer, offset);
<a name="line383">383  |</a>             lexer-&gt;error = yajl_lex_string_invalid_json_char;
<a name="line384">384  |</a>             goto finish_string_lex;
<a name="line385">385  |</a>         }
<a name="line386">386  |</a>         /* when in validate UTF8 mode we need to do some extra work */
<a name="line387">387  |</a>         else if (lexer-&gt;validateUTF8) {
<a name="line388">388  |</a>             yajl_tok t = yajl_lex_utf8_char(lexer, jsonText, jsonTextLen,
<a name="line389">389  |</a>                                             offset, (unsigned int) curChar);
<a name="line390">390  |</a> 
<a name="line391">391  |</a>             if (t == yajl_tok_eof) {
<a name="line392">392  |</a>                 tok = yajl_tok_eof;
<a name="line393">393  |</a>                 goto finish_string_lex;
<a name="line394">394  |</a>             } else if (t == yajl_tok_error) {
<a name="line395">395  |</a>                 lexer-&gt;error = yajl_lex_string_invalid_utf8;
<a name="line396">396  |</a>                 goto finish_string_lex;
<a name="line397">397  |</a>             }
<a name="line398">398  |</a>         }
<a name="line399">399  |</a>         /* accept it, and move on */
<a name="line400">400  |</a>     }
<a name="line401">401  |</a>   finish_string_lex:
<a name="line402">402  |</a>     /* tell our buddy, the parser, wether he needs to process this string
<a name="line403">403  |</a>      * again */
<a name="line404">404  |</a>     if (hasEscapes &amp;&amp; tok == yajl_tok_string) {
<a name="line405">405  |</a>         tok = yajl_tok_string_with_escapes;
<a name="line406">406  |</a>     }
<a name="line407">407  |</a> 
<a name="line408">408  |</a>     return tok;
<a name="line409">409  |</a> }
<a name="line410">410  |</a> 
<a name="line411">411  |</a> #define RETURN_IF_EOF if (*offset &gt;= jsonTextLen) return yajl_tok_eof;
<a name="line412">412  |</a> 
<a name="line413">413  |</a> static yajl_tok
<a name="line414">414  |</a> yajl_lex_number(yajl_lexer lexer, const unsigned char * jsonText,
<a name="line415">415  |</a>                 size_t jsonTextLen, size_t * offset)
<a name="line416">416  |</a> {
<a name="line417">417  |</a>     /*
<a name="line418">418  |</a>      * XXX:  numbers are the only entities in json that we must lex
<a name="line419">419  |</a>      *       _beyond_ in order to know that they are complete.  There
<a name="line420">420  |</a>      *       is an ambiguous case for integers at EOF.
<a name="line421">421  |</a>      */
<a name="line422">422  |</a> 
<a name="line423">423  |</a>     unsigned char c;
<a name="line424">424  |</a> 
<a name="line425">425  |</a>     yajl_tok tok = yajl_tok_integer;
<a name="line426">426  |</a> 
<a name="line427">427  |</a>     RETURN_IF_EOF;
<a name="line428">428  |</a>     c = readChar(lexer, jsonText, offset);
<a name="line429">429  |</a> 
<a name="line430">430  |</a>     /* optional leading minus */
<a name="line431">431  |</a>     if (c == '-') {
<a name="line432">432  |</a>         RETURN_IF_EOF;
<a name="line433">433  |</a>         c = readChar(lexer, jsonText, offset);
<a name="line434">434  |</a>     }
<a name="line435">435  |</a> 
<a name="line436">436  |</a>     /* a single zero, or a series of integers */
<a name="line437">437  |</a>     if (c == '0') {
<a name="line438">438  |</a>         RETURN_IF_EOF;
<a name="line439">439  |</a>         c = readChar(lexer, jsonText, offset);
<a name="line440">440  |</a>     } else if (c &gt;= '1' &amp;&amp; c &lt;= '9') {
<a name="line441">441  |</a>         do {
<a name="line442">442  |</a>             RETURN_IF_EOF;
<a name="line443">443  |</a>             c = readChar(lexer, jsonText, offset);
<a name="line444">444  |</a>         } while (c &gt;= '0' &amp;&amp; c &lt;= '9');
<a name="line445">445  |</a>     } else {
<a name="line446">446  |</a>         unreadChar(lexer, offset);
<a name="line447">447  |</a>         lexer-&gt;error = yajl_lex_missing_integer_after_minus;
<a name="line448">448  |</a>         return yajl_tok_error;
<a name="line449">449  |</a>     }
<a name="line450">450  |</a> 
<a name="line451">451  |</a>     /* optional fraction (indicates this is floating point) */
<a name="line452">452  |</a>     if (c == '.') {
<a name="line453">453  |</a>         int numRd = 0;
<a name="line454">454  |</a> 
<a name="line455">455  |</a>         RETURN_IF_EOF;
<a name="line456">456  |</a>         c = readChar(lexer, jsonText, offset);
<a name="line457">457  |</a> 
<a name="line458">458  |</a>         while (c &gt;= '0' &amp;&amp; c &lt;= '9') {
<a name="line459">459  |</a>             numRd++;
<a name="line460">460  |</a>             RETURN_IF_EOF;
<a name="line461">461  |</a>             c = readChar(lexer, jsonText, offset);
<a name="line462">462  |</a>         }
<a name="line463">463  |</a> 
<a name="line464">464  |</a>         if (!numRd) {
<a name="line465">465  |</a>             unreadChar(lexer, offset);
<a name="line466">466  |</a>             lexer-&gt;error = yajl_lex_missing_integer_after_decimal;
<a name="line467">467  |</a>             return yajl_tok_error;
<a name="line468">468  |</a>         }
<a name="line469">469  |</a>         tok = yajl_tok_double;
<a name="line470">470  |</a>     }
<a name="line471">471  |</a> 
<a name="line472">472  |</a>     /* optional exponent (indicates this is floating point) */
<a name="line473">473  |</a>     if (c == 'e' || c == 'E') {
<a name="line474">474  |</a>         RETURN_IF_EOF;
<a name="line475">475  |</a>         c = readChar(lexer, jsonText, offset);
<a name="line476">476  |</a> 
<a name="line477">477  |</a>         /* optional sign */
<a name="line478">478  |</a>         if (c == '+' || c == '-') {
<a name="line479">479  |</a>             RETURN_IF_EOF;
<a name="line480">480  |</a>             c = readChar(lexer, jsonText, offset);
<a name="line481">481  |</a>         }
<a name="line482">482  |</a> 
<a name="line483">483  |</a>         if (c &gt;= '0' &amp;&amp; c &lt;= '9') {
<a name="line484">484  |</a>             do {
<a name="line485">485  |</a>                 RETURN_IF_EOF;
<a name="line486">486  |</a>                 c = readChar(lexer, jsonText, offset);
<a name="line487">487  |</a>             } while (c &gt;= '0' &amp;&amp; c &lt;= '9');
<a name="line488">488  |</a>         } else {
<a name="line489">489  |</a>             unreadChar(lexer, offset);
<a name="line490">490  |</a>             lexer-&gt;error = yajl_lex_missing_integer_after_exponent;
<a name="line491">491  |</a>             return yajl_tok_error;
<a name="line492">492  |</a>         }
<a name="line493">493  |</a>         tok = yajl_tok_double;
<a name="line494">494  |</a>     }
<a name="line495">495  |</a> 
<a name="line496">496  |</a>     /* we always go "one too far" */
<a name="line497">497  |</a>     unreadChar(lexer, offset);
<a name="line498">498  |</a> 
<a name="line499">499  |</a>     return tok;
<a name="line500">500  |</a> }
<a name="line501">501  |</a> 
<a name="line502">502  |</a> static yajl_tok
<a name="line503">503  |</a> yajl_lex_comment(yajl_lexer lexer, const unsigned char * jsonText,
<a name="line504">504  |</a>                  size_t jsonTextLen, size_t * offset)
<a name="line505">505  |</a> {
<a name="line506">506  |</a>     unsigned char c;
<a name="line507">507  |</a> 
<a name="line508">508  |</a>     yajl_tok tok = yajl_tok_comment;
<a name="line509">509  |</a> 
<a name="line510">510  |</a>     RETURN_IF_EOF;
<a name="line511">511  |</a>     c = readChar(lexer, jsonText, offset);
<a name="line512">512  |</a> 
<a name="line513">513  |</a>     /* either slash or star expected */
<a name="line514">514  |</a>     if (c == '/') {
<a name="line515">515  |</a>         /* now we throw away until end of line */
<a name="line516">516  |</a>         do {
<a name="line517">517  |</a>             RETURN_IF_EOF;
<a name="line518">518  |</a>             c = readChar(lexer, jsonText, offset);
<a name="line519">519  |</a>         } while (c != '\n');
<a name="line520">520  |</a>     } else if (c == '*') {
<a name="line521">521  |</a>         /* now we throw away until end of comment */
<a name="line522">522  |</a>         for (;;) {
<a name="line523">523  |</a>             RETURN_IF_EOF;
<a name="line524">524  |</a>             c = readChar(lexer, jsonText, offset);
<a name="line525">525  |</a>             if (c == '*') {
<a name="line526">526  |</a>                 RETURN_IF_EOF;
<a name="line527">527  |</a>                 c = readChar(lexer, jsonText, offset);
<a name="line528">528  |</a>                 if (c == '/') {
<a name="line529">529  |</a>                     break;
<a name="line530">530  |</a>                 } else {
<a name="line531">531  |</a>                     unreadChar(lexer, offset);
<a name="line532">532  |</a>                 }
<a name="line533">533  |</a>             }
<a name="line534">534  |</a>         }
<a name="line535">535  |</a>     } else {
<a name="line536">536  |</a>         lexer-&gt;error = yajl_lex_invalid_char;
<a name="line537">537  |</a>         tok = yajl_tok_error;
<a name="line538">538  |</a>     }
<a name="line539">539  |</a> 
<a name="line540">540  |</a>     return tok;
<a name="line541">541  |</a> }
<a name="line542">542  |</a> 
<a name="line543">543  |</a> /*+
<a name="line544">544  |</a>  * Begin or continue a lexer.
<a name="line545">545  |</a>  *
<a name="line546">546  |</a>  * Returns a JSON lexical token for the parser.
<a name="line547">547  |</a>  *
<a name="line548">548  |</a>  * When you pass the next chunk of data, context should be reinitialized to
<a name="line549">549  |</a>  * zero.  xxx ???
<a name="line550">550  |</a>  +*/
<a name="line551">551  |</a> yajl_tok
<a name="line552">552  |</a> yajl_lex_lex(yajl_lexer lexer,          /*+ the current lexer context +*/
<a name="line553">553  |</a>              const unsigned char * jsonText, /*+ a chunk of JSON text to be analysed +*/
<a name="line554">554  |</a>              size_t jsonTextLen,             /*+ length of this chunk +*/
<a name="line555">555  |</a>              size_t * offset,           /*+ Offset is both input &amp; output!  It
<a name="line556">556  |</a>                                          * should be initialized to zero for a
<a name="line557">557  |</a>                                          * new chunk of target text, and upon
<a name="line558">558  |</a>                                          * subsetquent calls with the same
<a name="line559">559  |</a>                                          * target text should passed with the
<a name="line560">560  |</a>                                          * value of the previous invocation.
<a name="line561">561  |</a>                                          *
<a name="line562">562  |</a>                                          * The caller may be interested in the
<a name="line563">563  |</a>                                          * value of offset when an error is
<a name="line564">564  |</a>                                          * returned from the lexer.  This allows
<a name="line565">565  |</a>                                          * the caller to render useful error
<a name="line566">566  |</a>                                          * messages.
<a name="line567">567  |</a>                                          +*/
<a name="line568">568  |</a>              const unsigned char ** outBuf, /*+ Finally, the output buffer is
<a name="line569">569  |</a>                                              * usually just a pointer into the
<a name="line570">570  |</a>                                              * jsonText, however in cases where
<a name="line571">571  |</a>                                              * the entity being lexed spans
<a name="line572">572  |</a>                                              * multiple chunks, the lexer will
<a name="line573">573  |</a>                                              * buffer the entity and the data
<a name="line574">574  |</a>                                              * returned will be a pointer into
<a name="line575">575  |</a>                                              * that buffer. +*/
<a name="line576">576  |</a>              size_t * outLen)           /*+ This behavior is abstracted from
<a name="line577">577  |</a>                                          * client code except for the
<a name="line578">578  |</a>                                          * performance implications which
<a name="line579">579  |</a>                                          * require that the client choose a
<a name="line580">580  |</a>                                          * reasonable chunk size to get adequate
<a name="line581">581  |</a>                                          * performance. +*/
<a name="line582">582  |</a> {
<a name="line583">583  |</a>     yajl_tok tok = yajl_tok_error;
<a name="line584">584  |</a>     unsigned char c;
<a name="line585">585  |</a>     size_t startOffset = *offset;
<a name="line586">586  |</a> 
<a name="line587">587  |</a>     *outBuf = NULL;
<a name="line588">588  |</a>     *outLen = 0;
<a name="line589">589  |</a> 
<a name="line590">590  |</a>     for (;;) {
<a name="line591">591  |</a>         assert(*offset &lt;= jsonTextLen);
<a name="line592">592  |</a> 
<a name="line593">593  |</a>         if (*offset &gt;= jsonTextLen) {
<a name="line594">594  |</a>             tok = yajl_tok_eof;
<a name="line595">595  |</a>             goto lexed;
<a name="line596">596  |</a>         }
<a name="line597">597  |</a> 
<a name="line598">598  |</a>         c = readChar(lexer, jsonText, offset);
<a name="line599">599  |</a> 
<a name="line600">600  |</a>         switch (c) {
<a name="line601">601  |</a>             case '{':
<a name="line602">602  |</a>                 tok = yajl_tok_left_bracket;
<a name="line603">603  |</a>                 goto lexed;
<a name="line604">604  |</a>             case '}':
<a name="line605">605  |</a>                 tok = yajl_tok_right_bracket;
<a name="line606">606  |</a>                 goto lexed;
<a name="line607">607  |</a>             case '[':
<a name="line608">608  |</a>                 tok = yajl_tok_left_brace;
<a name="line609">609  |</a>                 goto lexed;
<a name="line610">610  |</a>             case ']':
<a name="line611">611  |</a>                 tok = yajl_tok_right_brace;
<a name="line612">612  |</a>                 goto lexed;
<a name="line613">613  |</a>             case ',':
<a name="line614">614  |</a>                 tok = yajl_tok_comma;
<a name="line615">615  |</a>                 goto lexed;
<a name="line616">616  |</a>             case ':':
<a name="line617">617  |</a>                 tok = yajl_tok_colon;
<a name="line618">618  |</a>                 goto lexed;
<a name="line619">619  |</a>             case '\t': case '\n': case '\v': case '\f': case '\r': case ' ':
<a name="line620">620  |</a>                 startOffset++;
<a name="line621">621  |</a>                 break;
<a name="line622">622  |</a>             case 't': {
<a name="line623">623  |</a>                 const char * want = "rue";
<a name="line624">624  |</a>                 do {
<a name="line625">625  |</a>                     if (*offset &gt;= jsonTextLen) {
<a name="line626">626  |</a>                         tok = yajl_tok_eof;
<a name="line627">627  |</a>                         goto lexed;
<a name="line628">628  |</a>                     }
<a name="line629">629  |</a>                     c = readChar(lexer, jsonText, offset);
<a name="line630">630  |</a>                     if (c != *want) {
<a name="line631">631  |</a>                         unreadChar(lexer, offset);
<a name="line632">632  |</a>                         lexer-&gt;error = yajl_lex_invalid_string;
<a name="line633">633  |</a>                         tok = yajl_tok_error;
<a name="line634">634  |</a>                         goto lexed;
<a name="line635">635  |</a>                     }
<a name="line636">636  |</a>                 } while (*(++want));
<a name="line637">637  |</a>                 tok = yajl_tok_bool;
<a name="line638">638  |</a>                 goto lexed;
<a name="line639">639  |</a>             }
<a name="line640">640  |</a>             case 'f': {
<a name="line641">641  |</a>                 const char * want = "alse";
<a name="line642">642  |</a>                 do {
<a name="line643">643  |</a>                     if (*offset &gt;= jsonTextLen) {
<a name="line644">644  |</a>                         tok = yajl_tok_eof;
<a name="line645">645  |</a>                         goto lexed;
<a name="line646">646  |</a>                     }
<a name="line647">647  |</a>                     c = readChar(lexer, jsonText, offset);
<a name="line648">648  |</a>                     if (c != *want) {
<a name="line649">649  |</a>                         unreadChar(lexer, offset);
<a name="line650">650  |</a>                         lexer-&gt;error = yajl_lex_invalid_string;
<a name="line651">651  |</a>                         tok = yajl_tok_error;
<a name="line652">652  |</a>                         goto lexed;
<a name="line653">653  |</a>                     }
<a name="line654">654  |</a>                 } while (*(++want));
<a name="line655">655  |</a>                 tok = yajl_tok_bool;
<a name="line656">656  |</a>                 goto lexed;
<a name="line657">657  |</a>             }
<a name="line658">658  |</a>             case 'n': {
<a name="line659">659  |</a>                 const char * want = "ull";
<a name="line660">660  |</a>                 do {
<a name="line661">661  |</a>                     if (*offset &gt;= jsonTextLen) {
<a name="line662">662  |</a>                         tok = yajl_tok_eof;
<a name="line663">663  |</a>                         goto lexed;
<a name="line664">664  |</a>                     }
<a name="line665">665  |</a>                     c = readChar(lexer, jsonText, offset);
<a name="line666">666  |</a>                     if (c != *want) {
<a name="line667">667  |</a>                         unreadChar(lexer, offset);
<a name="line668">668  |</a>                         lexer-&gt;error = yajl_lex_invalid_string;
<a name="line669">669  |</a>                         tok = yajl_tok_error;
<a name="line670">670  |</a>                         goto lexed;
<a name="line671">671  |</a>                     }
<a name="line672">672  |</a>                 } while (*(++want));
<a name="line673">673  |</a>                 tok = yajl_tok_null;
<a name="line674">674  |</a>                 goto lexed;
<a name="line675">675  |</a>             }
<a name="line676">676  |</a>             case '"': {
<a name="line677">677  |</a>                 tok = yajl_lex_string(lexer, (const unsigned char *) jsonText,
<a name="line678">678  |</a>                                       jsonTextLen, offset);
<a name="line679">679  |</a>                 goto lexed;
<a name="line680">680  |</a>             }
<a name="line681">681  |</a>             case '-':
<a name="line682">682  |</a>             case '0': case '1': case '2': case '3': case '4':
<a name="line683">683  |</a>             case '5': case '6': case '7': case '8': case '9': {
<a name="line684">684  |</a>                 /* integer parsing wants to start from the beginning */
<a name="line685">685  |</a>                 unreadChar(lexer, offset);
<a name="line686">686  |</a>                 tok = yajl_lex_number(lexer, (const unsigned char *) jsonText,
<a name="line687">687  |</a>                                       jsonTextLen, offset);
<a name="line688">688  |</a>                 goto lexed;
<a name="line689">689  |</a>             }
<a name="line690">690  |</a>             case '/':
<a name="line691">691  |</a>                 /* hey, look, a probable comment!  If comments are disabled
<a name="line692">692  |</a>                  * it's an error. */
<a name="line693">693  |</a>                 if (!lexer-&gt;allowComments) {
<a name="line694">694  |</a>                     unreadChar(lexer, offset);
<a name="line695">695  |</a>                     lexer-&gt;error = yajl_lex_unallowed_comment;
<a name="line696">696  |</a>                     tok = yajl_tok_error;
<a name="line697">697  |</a>                     goto lexed;
<a name="line698">698  |</a>                 }
<a name="line699">699  |</a>                 /* if comments are enabled, then we should try to lex
<a name="line700">700  |</a>                  * the thing.  possible outcomes are
<a name="line701">701  |</a>                  * - successful lex (tok_comment, which means continue),
<a name="line702">702  |</a>                  * - malformed comment opening (slash not followed by
<a name="line703">703  |</a>                  *   '*' or '/') (tok_error)
<a name="line704">704  |</a>                  * - eof hit. (tok_eof) */
<a name="line705">705  |</a>                 tok = yajl_lex_comment(lexer, (const unsigned char *) jsonText,
<a name="line706">706  |</a>                                        jsonTextLen, offset);
<a name="line707">707  |</a>                 if (tok == yajl_tok_comment) {
<a name="line708">708  |</a>                     /* "error" is silly, but that's the initial
<a name="line709">709  |</a>                      * state of tok.  guilty until proven innocent. */
<a name="line710">710  |</a>                     tok = yajl_tok_error;
<a name="line711">711  |</a>                     yajl_buf_clear(lexer-&gt;buf);
<a name="line712">712  |</a>                     lexer-&gt;bufInUse = 0;
<a name="line713">713  |</a>                     startOffset = *offset;
<a name="line714">714  |</a>                     break;
<a name="line715">715  |</a>                 }
<a name="line716">716  |</a>                 /* hit error or eof, bail */
<a name="line717">717  |</a>                 goto lexed;
<a name="line718">718  |</a>             default:
<a name="line719">719  |</a>                 lexer-&gt;error = yajl_lex_invalid_char;
<a name="line720">720  |</a>                 tok = yajl_tok_error;
<a name="line721">721  |</a>                 goto lexed;
<a name="line722">722  |</a>         }
<a name="line723">723  |</a>     }
<a name="line724">724  |</a> 
<a name="line725">725  |</a> 
<a name="line726">726  |</a>   lexed:
<a name="line727">727  |</a>     /* need to append to buffer if the buffer is in use or
<a name="line728">728  |</a>      * if it's an EOF token */
<a name="line729">729  |</a>     if (tok == yajl_tok_eof || lexer-&gt;bufInUse) {
<a name="line730">730  |</a>         if (!lexer-&gt;bufInUse) yajl_buf_clear(lexer-&gt;buf);
<a name="line731">731  |</a>         lexer-&gt;bufInUse = 1;
<a name="line732">732  |</a>         yajl_buf_append(lexer-&gt;buf, jsonText + startOffset, *offset - startOffset);
<a name="line733">733  |</a>         lexer-&gt;bufOff = 0;
<a name="line734">734  |</a> 
<a name="line735">735  |</a>         if (tok != yajl_tok_eof) {
<a name="line736">736  |</a>             *outBuf = yajl_buf_data(lexer-&gt;buf);
<a name="line737">737  |</a>             *outLen = yajl_buf_len(lexer-&gt;buf);
<a name="line738">738  |</a>             lexer-&gt;bufInUse = 0;
<a name="line739">739  |</a>         }
<a name="line740">740  |</a>     } else if (tok != yajl_tok_error) {
<a name="line741">741  |</a>         *outBuf = jsonText + startOffset;
<a name="line742">742  |</a>         *outLen = *offset - startOffset;
<a name="line743">743  |</a>     }
<a name="line744">744  |</a> 
<a name="line745">745  |</a>     /* special case for strings. skip the quotes. */
<a name="line746">746  |</a>     if (tok == yajl_tok_string || tok == yajl_tok_string_with_escapes)
<a name="line747">747  |</a>     {
<a name="line748">748  |</a>         assert(*outLen &gt;= 2);
<a name="line749">749  |</a>         (*outBuf)++;
<a name="line750">750  |</a>         *outLen -= 2;
<a name="line751">751  |</a>     }
<a name="line752">752  |</a> 
<a name="line753">753  |</a> 
<a name="line754">754  |</a> #ifdef YAJL_LEXER_DEBUG
<a name="line755">755  |</a>     if (tok == yajl_tok_error) {
<a name="line756">756  |</a>         printf("lexical error: %s\n",
<a name="line757">757  |</a>                yajl_lex_error_to_string(yajl_lex_get_error(lexer)));
<a name="line758">758  |</a>     } else if (tok == yajl_tok_eof) {
<a name="line759">759  |</a>         printf("EOF hit\n");
<a name="line760">760  |</a>     } else {
<a name="line761">761  |</a>         printf("lexed %s: '", tokToStr(tok));
<a name="line762">762  |</a>         fwrite(*outBuf, (size_t) 1, *outLen, stdout);
<a name="line763">763  |</a>         printf("'\n");
<a name="line764">764  |</a>     }
<a name="line765">765  |</a> #endif
<a name="line766">766  |</a> 
<a name="line767">767  |</a>     return tok;
<a name="line768">768  |</a> }
<a name="line769">769  |</a> 
<a name="line770">770  |</a> /*+
<a name="line771">771  |</a>  *  convert a lexer error value returned by yajl_lex_get_error() to a
<a name="line772">772  |</a>  *  descriptive string
<a name="line773">773  |</a>  +*/
<a name="line774">774  |</a> const char *
<a name="line775">775  |</a> yajl_lex_error_to_string(yajl_lex_error error) /*+ lexer error value +*/
<a name="line776">776  |</a> {
<a name="line777">777  |</a>     switch (error) {
<a name="line778">778  |</a>         case yajl_lex_e_ok:
<a name="line779">779  |</a>             return "ok, no error";
<a name="line780">780  |</a>         case yajl_lex_string_invalid_utf8:
<a name="line781">781  |</a>             return "invalid bytes in UTF8 string.";
<a name="line782">782  |</a>         case yajl_lex_string_invalid_escaped_char:
<a name="line783">783  |</a>             return "inside a string, '\\' occurs before a character "
<a name="line784">784  |</a>                    "which it may not.";
<a name="line785">785  |</a>         case yajl_lex_string_invalid_json_char:
<a name="line786">786  |</a>             return "invalid character inside string.";
<a name="line787">787  |</a>         case yajl_lex_string_invalid_hex_char:
<a name="line788">788  |</a>             return "invalid (non-hex) character occurs after '\\u' inside "
<a name="line789">789  |</a>                    "string.";
<a name="line790">790  |</a>         case yajl_lex_invalid_char:
<a name="line791">791  |</a>             return "invalid char in json text.";
<a name="line792">792  |</a>         case yajl_lex_invalid_string:
<a name="line793">793  |</a>             return "invalid string in json text.";
<a name="line794">794  |</a>         case yajl_lex_missing_integer_after_exponent:
<a name="line795">795  |</a>             return "malformed number, a digit is required after the exponent.";
<a name="line796">796  |</a>         case yajl_lex_missing_integer_after_decimal:
<a name="line797">797  |</a>             return "malformed number, a digit is required after the "
<a name="line798">798  |</a>                    "decimal point.";
<a name="line799">799  |</a>         case yajl_lex_missing_integer_after_minus:
<a name="line800">800  |</a>             return "malformed number, a digit is required after the "
<a name="line801">801  |</a>                    "minus sign.";
<a name="line802">802  |</a>         case yajl_lex_unallowed_comment:
<a name="line803">803  |</a>             return "probable comment found in input text, comments are "
<a name="line804">804  |</a>                    "not enabled.";
<a name="line805">805  |</a>     }
<a name="line806">806  |</a>     /* NOTREACHED */
<a name="line807">807  |</a>     return "unknown error code";
<a name="line808">808  |</a> }
<a name="line809">809  |</a> 
<a name="line810">810  |</a> 
<a name="line811">811  |</a> /*+
<a name="line812">812  |</a>  *  allows access to more specific information about the lexical
<a name="line813">813  |</a>  *  error when yajl_lex_lex() returns yajl_tok_error.
<a name="line814">814  |</a>  *
<a name="line815">815  |</a>  *  Retunrs a value that may be passed to yajl_lex_error_to_string() to convert
<a name="line816">816  |</a>  *  it into descriptive error message text.
<a name="line817">817  |</a>  +*/
<a name="line818">818  |</a> yajl_lex_error
<a name="line819">819  |</a> yajl_lex_get_error(yajl_lexer lexer)    /*+ the current lexer context +*/
<a name="line820">820  |</a> {
<a name="line821">821  |</a>     if (lexer == NULL) return (yajl_lex_error) -1;
<a name="line822">822  |</a>     return lexer-&gt;error;
<a name="line823">823  |</a> }
<a name="line824">824  |</a> 
<a name="line825">825  |</a> /*+
<a name="line826">826  |</a>  *  A helper for finding the line number of error in the input.
<a name="line827">827  |</a>  *
<a name="line828">828  |</a>  *  Returns the number of lines lexed by this lexer instance
<a name="line829">829  |</a>  +*/
<a name="line830">830  |</a> size_t
<a name="line831">831  |</a> yajl_lex_current_line(yajl_lexer lexer) /*+ the current lexer context +*/
<a name="line832">832  |</a> {
<a name="line833">833  |</a>     return lexer-&gt;lineOff;
<a name="line834">834  |</a> }
<a name="line835">835  |</a> 
<a name="line836">836  |</a> /*+
<a name="line837">837  |</a>  *  A helper for finding the exact context of an error in the input.
<a name="line838">838  |</a>  *
<a name="line839">839  |</a>  *  get the number of chars lexed by this lexer instance since the last
<a name="line840">840  |</a>  *  \n or \r
<a name="line841">841  |</a>  +*/
<a name="line842">842  |</a> size_t
<a name="line843">843  |</a> yajl_lex_current_char(yajl_lexer lexer) /*+ the current lexer context +*/
<a name="line844">844  |</a> {
<a name="line845">845  |</a>     return lexer-&gt;charOff;
<a name="line846">846  |</a> }
<a name="line847">847  |</a> 
<a name="line848">848  |</a> /*+
<a name="line849">849  |</a>  * have a peek at the next token, but don't move the lexer forward
<a name="line850">850  |</a>  *
<a name="line851">851  |</a>  * Returns the next token yagl_lex_lex() will return.
<a name="line852">852  |</a>  +*/
<a name="line853">853  |</a> yajl_tok
<a name="line854">854  |</a> yajl_lex_peek(yajl_lexer lexer, /*+ the current lexer context +*/
<a name="line855">855  |</a>                        const unsigned char * jsonText,
<a name="line856">856  |</a>                        size_t jsonTextLen,
<a name="line857">857  |</a>                        size_t offset)
<a name="line858">858  |</a> {
<a name="line859">859  |</a>     const unsigned char * outBuf;
<a name="line860">860  |</a>     size_t outLen;
<a name="line861">861  |</a>     size_t bufLen = yajl_buf_len(lexer-&gt;buf);
<a name="line862">862  |</a>     size_t bufOff = lexer-&gt;bufOff;
<a name="line863">863  |</a>     /* bool */ int bufInUse = lexer-&gt;bufInUse;
<a name="line864">864  |</a>     yajl_tok tok;
<a name="line865">865  |</a> 
<a name="line866">866  |</a>     tok = yajl_lex_lex(lexer, jsonText, jsonTextLen, &amp;offset,
<a name="line867">867  |</a>                        &amp;outBuf, &amp;outLen);
<a name="line868">868  |</a> 
<a name="line869">869  |</a>     lexer-&gt;bufOff = bufOff;
<a name="line870">870  |</a>     lexer-&gt;bufInUse = bufInUse;
<a name="line871">871  |</a>     yajl_buf_truncate(lexer-&gt;buf, bufLen);
<a name="line872">872  |</a> 
<a name="line873">873  |</a>     return tok;
<a name="line874">874  |</a> }
</pre>

</BODY>
</HTML>
