<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<!-- This HTML file generated by cxref (version 1.6d). -->
<!-- cxref program (c) Andrew M. Bishop 1995-2011. -->

<!--
Cxref: cxref -warn-all -xref-all -block-comments -O/work/woods/f-yajl/build/work/woods/f-yajl/doc/html -Nyajl -html -html-src -I/work/woods/f-yajl/src -I/work/woods/f-yajl/build/work/woods/f-yajl/./src-CPP "cc -E -CC -x c" src/yajl_gen.c
CPP  : cc -E -CC -x c -Isrc -Ibuild/work/woods/f-yajl/./src
-->

<HTML>

<HEAD>
<TITLE>Source File src/yajl_gen.c</TITLE>
<LINK rel="stylesheet" href="../cxref.css" type="text/css">
</HEAD>

<BODY>

<pre>
<a name="line1">1    |</a> /*
<a name="line2">2    |</a>  * Copyright (c) 2007-2014, Lloyd Hilaiel &lt;me@lloyd.io&gt;
<a name="line3">3    |</a>  *
<a name="line4">4    |</a>  * Permission to use, copy, modify, and/or distribute this software for any
<a name="line5">5    |</a>  * purpose with or without fee is hereby granted, provided that the above
<a name="line6">6    |</a>  * copyright notice and this permission notice appear in all copies.
<a name="line7">7    |</a>  *
<a name="line8">8    |</a>  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
<a name="line9">9    |</a>  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
<a name="line10">10   |</a>  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
<a name="line11">11   |</a>  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
<a name="line12">12   |</a>  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
<a name="line13">13   |</a>  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
<a name="line14">14   |</a>  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
<a name="line15">15   |</a>  */
<a name="line16">16   |</a> 
<a name="line17">17   |</a> /**
<a name="line18">18   |</a>  * Interface to YAJL's JSON generation facilities.
<a name="line19">19   |</a>  **/
<a name="line20">20   |</a> 
<a name="line21">21   |</a> #include "yajl/yajl_gen.h"
<a name="line22">22   |</a> #include "yajl_buf.h"
<a name="line23">23   |</a> #include "yajl_encode.h"
<a name="line24">24   |</a> 
<a name="line25">25   |</a> #include &lt;stdlib.h&gt;
<a name="line26">26   |</a> #include &lt;string.h&gt;
<a name="line27">27   |</a> #include &lt;stdio.h&gt;
<a name="line28">28   |</a> #include &lt;math.h&gt;
<a name="line29">29   |</a> #include &lt;stdarg.h&gt;
<a name="line30">30   |</a> 
<a name="line31">31   |</a> typedef enum {
<a name="line32">32   |</a>     yajl_gen_start,
<a name="line33">33   |</a>     yajl_gen_map_start,
<a name="line34">34   |</a>     yajl_gen_map_key,
<a name="line35">35   |</a>     yajl_gen_map_val,
<a name="line36">36   |</a>     yajl_gen_array_start,
<a name="line37">37   |</a>     yajl_gen_in_array,
<a name="line38">38   |</a>     yajl_gen_complete,
<a name="line39">39   |</a>     yajl_gen_error
<a name="line40">40   |</a> } yajl_gen_state;
<a name="line41">41   |</a> 
<a name="line42">42   |</a> struct yajl_gen_t
<a name="line43">43   |</a> {
<a name="line44">44   |</a>     unsigned int flags;
<a name="line45">45   |</a>     unsigned int depth;
<a name="line46">46   |</a>     const char * indentString;
<a name="line47">47   |</a>     yajl_gen_state state[YAJL_MAX_DEPTH];
<a name="line48">48   |</a>     yajl_print_t print;
<a name="line49">49   |</a>     void * ctx; /* yajl_buf */
<a name="line50">50   |</a>     /* memory allocation routines */
<a name="line51">51   |</a>     yajl_alloc_funcs alloc;
<a name="line52">52   |</a> };
<a name="line53">53   |</a> 
<a name="line54">54   |</a> /*+
<a name="line55">55   |</a>  *  allow the modification of generator options subsequent to handle
<a name="line56">56   |</a>  *  allocation (via yajl_alloc)
<a name="line57">57   |</a>  *
<a name="line58">58   |</a>  *  \returns zero in case of errors, non-zero otherwise
<a name="line59">59   |</a>  +*/
<a name="line60">60   |</a> int
<a name="line61">61   |</a> yajl_gen_config(yajl_gen g, yajl_gen_option opt, ...)
<a name="line62">62   |</a> {
<a name="line63">63   |</a>     int rv = 1;
<a name="line64">64   |</a>     va_list ap;
<a name="line65">65   |</a>     va_start(ap, opt);
<a name="line66">66   |</a> 
<a name="line67">67   |</a>     switch(opt) {
<a name="line68">68   |</a>         case yajl_gen_beautify:
<a name="line69">69   |</a>         case yajl_gen_validate_utf8:
<a name="line70">70   |</a>         case yajl_gen_escape_solidus:
<a name="line71">71   |</a>             if (va_arg(ap, int)) g-&gt;flags |= opt;
<a name="line72">72   |</a>             else g-&gt;flags &amp;= ~opt;
<a name="line73">73   |</a>             break;
<a name="line74">74   |</a>         case yajl_gen_indent_string: {
<a name="line75">75   |</a>             const char *indent = va_arg(ap, const char *);
<a name="line76">76   |</a>             g-&gt;indentString = indent;
<a name="line77">77   |</a>             for (; *indent; indent++) {
<a name="line78">78   |</a>                 if (*indent != '\n'
<a name="line79">79   |</a>                     &amp;&amp; *indent != '\v'
<a name="line80">80   |</a>                     &amp;&amp; *indent != '\f'
<a name="line81">81   |</a>                     &amp;&amp; *indent != '\t'
<a name="line82">82   |</a>                     &amp;&amp; *indent != '\r'
<a name="line83">83   |</a>                     &amp;&amp; *indent != ' ')
<a name="line84">84   |</a>                 {
<a name="line85">85   |</a>                     g-&gt;indentString = NULL;
<a name="line86">86   |</a>                     rv = 0;
<a name="line87">87   |</a>                 }
<a name="line88">88   |</a>             }
<a name="line89">89   |</a>             break;
<a name="line90">90   |</a>         }
<a name="line91">91   |</a>         case yajl_gen_print_callback:
<a name="line92">92   |</a>             yajl_buf_free(g-&gt;ctx);
<a name="line93">93   |</a>             g-&gt;print = va_arg(ap, const yajl_print_t);
<a name="line94">94   |</a>             g-&gt;ctx = va_arg(ap, void *);
<a name="line95">95   |</a>             break;
<a name="line96">96   |</a>         default:
<a name="line97">97   |</a>             rv = 0;
<a name="line98">98   |</a>     }
<a name="line99">99   |</a> 
<a name="line100">100  |</a>     va_end(ap);
<a name="line101">101  |</a> 
<a name="line102">102  |</a>     return rv;
<a name="line103">103  |</a> }
<a name="line104">104  |</a> 
<a name="line105">105  |</a> 
<a name="line106">106  |</a> 
<a name="line107">107  |</a> /*+ allocate a generator handle
<a name="line108">108  |</a>  *
<a name="line109">109  |</a>  *  \param allocFuncs an optional pointer to a structure which allows
<a name="line110">110  |</a>  *                    the client to overide the memory allocation
<a name="line111">111  |</a>  *                    used by yajl.  May be NULL, in which case
<a name="line112">112  |</a>  *                    malloc/free/realloc will be used.
<a name="line113">113  |</a>  *
<a name="line114">114  |</a>  *  \returns an allocated handle on success, NULL on failure (bad params)
<a name="line115">115  |</a>  +*/
<a name="line116">116  |</a> yajl_gen
<a name="line117">117  |</a> yajl_gen_alloc(const yajl_alloc_funcs * afs)
<a name="line118">118  |</a> {
<a name="line119">119  |</a>     yajl_gen g = NULL;
<a name="line120">120  |</a>     yajl_alloc_funcs afsBuffer;
<a name="line121">121  |</a> 
<a name="line122">122  |</a>     /* first order of business is to set up memory allocation routines */
<a name="line123">123  |</a>     if (afs != NULL) {
<a name="line124">124  |</a>         if (afs-&gt;malloc == NULL || afs-&gt;realloc == NULL || afs-&gt;free == NULL) {
<a name="line125">125  |</a>             return NULL;
<a name="line126">126  |</a>         }
<a name="line127">127  |</a>     } else {
<a name="line128">128  |</a>         yajl_set_default_alloc_funcs(&amp;afsBuffer);
<a name="line129">129  |</a>         afs = &amp;afsBuffer;
<a name="line130">130  |</a>     }
<a name="line131">131  |</a> 
<a name="line132">132  |</a>     g = (yajl_gen) YA_MALLOC(afs, sizeof(struct yajl_gen_t));
<a name="line133">133  |</a>     if (!g) {
<a name="line134">134  |</a>         return NULL;
<a name="line135">135  |</a>     }
<a name="line136">136  |</a>     memset((void *) g, 0, sizeof(struct yajl_gen_t));
<a name="line137">137  |</a>     /* copy in pointers to allocation routines */
<a name="line138">138  |</a>     g-&gt;alloc = *afs;
<a name="line139">139  |</a> 
<a name="line140">140  |</a>     g-&gt;print = (yajl_print_t) &amp;yajl_buf_append;
<a name="line141">141  |</a>     g-&gt;ctx = yajl_buf_alloc(&amp;(g-&gt;alloc));
<a name="line142">142  |</a>     g-&gt;indentString = "    ";
<a name="line143">143  |</a> 
<a name="line144">144  |</a>     return g;
<a name="line145">145  |</a> }
<a name="line146">146  |</a> 
<a name="line147">147  |</a> /*+
<a name="line148">148  |</a>  *  Reset the generator state.  Allows a client to generate multiple json
<a name="line149">149  |</a>  *  entities in a stream. The "sep" string will be inserted to separate the
<a name="line150">150  |</a>  *  previously generated entity from the current, NULL means *no separation* of
<a name="line151">151  |</a>  *  entites (clients beware, generating multiple JSON numbers without a
<a name="line152">152  |</a>  *  separator, for instance, will result in ambiguous output)
<a name="line153">153  |</a>  *
<a name="line154">154  |</a>  *  Note: this call will not clear yajl's output buffer.  This may be
<a name="line155">155  |</a>  *  accomplished explicitly by calling yajl_gen_clear()
<a name="line156">156  |</a>  +*/
<a name="line157">157  |</a> void
<a name="line158">158  |</a> yajl_gen_reset(yajl_gen g, const char * sep)
<a name="line159">159  |</a> {
<a name="line160">160  |</a>     g-&gt;depth = 0;
<a name="line161">161  |</a>     memset((void *) &amp;(g-&gt;state), 0, sizeof(g-&gt;state));
<a name="line162">162  |</a>     if (sep != NULL) {
<a name="line163">163  |</a>         g-&gt;print(g-&gt;ctx, sep, strlen(sep));
<a name="line164">164  |</a>     }
<a name="line165">165  |</a> }
<a name="line166">166  |</a> 
<a name="line167">167  |</a> /*+ free a generator handle +*/
<a name="line168">168  |</a> void
<a name="line169">169  |</a> yajl_gen_free(yajl_gen g)
<a name="line170">170  |</a> {
<a name="line171">171  |</a>     if (g-&gt;print == (yajl_print_t) &amp;yajl_buf_append) {
<a name="line172">172  |</a>         yajl_buf_free((yajl_buf) g-&gt;ctx);
<a name="line173">173  |</a>     }
<a name="line174">174  |</a>     YA_FREE(&amp;(g-&gt;alloc), g);
<a name="line175">175  |</a> }
<a name="line176">176  |</a> 
<a name="line177">177  |</a> #define INSERT_SEP                                                      \
<a name="line178">178  |</a>     if (g-&gt;state[g-&gt;depth] == yajl_gen_map_key ||                       \
<a name="line179">179  |</a>         g-&gt;state[g-&gt;depth] == yajl_gen_in_array) {                      \
<a name="line180">180  |</a>         g-&gt;print(g-&gt;ctx, ",", (size_t) 1);                              \
<a name="line181">181  |</a>         if ((g-&gt;flags &amp; yajl_gen_beautify)) {                           \
<a name="line182">182  |</a>             g-&gt;print(g-&gt;ctx, "\n", (size_t) 1);                         \
<a name="line183">183  |</a>         }                                                               \
<a name="line184">184  |</a>     } else if (g-&gt;state[g-&gt;depth] == yajl_gen_map_val) {                \
<a name="line185">185  |</a>         g-&gt;print(g-&gt;ctx, ":", (size_t) 1);                              \
<a name="line186">186  |</a>         if ((g-&gt;flags &amp; yajl_gen_beautify))  {                          \
<a name="line187">187  |</a>             g-&gt;print(g-&gt;ctx, " ", (size_t) 1);                          \
<a name="line188">188  |</a>         }                                                               \
<a name="line189">189  |</a>    }
<a name="line190">190  |</a> 
<a name="line191">191  |</a> #define INSERT_WHITESPACE                                               \
<a name="line192">192  |</a>     if ((g-&gt;flags &amp; yajl_gen_beautify)) {                               \
<a name="line193">193  |</a>         if (g-&gt;state[g-&gt;depth] != yajl_gen_map_val) {                   \
<a name="line194">194  |</a>             unsigned int _i;                                            \
<a name="line195">195  |</a>             for (_i=0;_i&lt;g-&gt;depth;_i++) {                               \
<a name="line196">196  |</a>                 g-&gt;print(g-&gt;ctx,                                        \
<a name="line197">197  |</a>                          g-&gt;indentString,                               \
<a name="line198">198  |</a>                          (size_t) strlen(g-&gt;indentString));             \
<a name="line199">199  |</a>             }                                                           \
<a name="line200">200  |</a>         }                                                               \
<a name="line201">201  |</a>     }
<a name="line202">202  |</a> 
<a name="line203">203  |</a> #define ENSURE_NOT_KEY                                  \
<a name="line204">204  |</a>     if (g-&gt;state[g-&gt;depth] == yajl_gen_map_key ||       \
<a name="line205">205  |</a>         g-&gt;state[g-&gt;depth] == yajl_gen_map_start)  {    \
<a name="line206">206  |</a>         return yajl_gen_keys_must_be_strings;           \
<a name="line207">207  |</a>     }                                                   \
<a name="line208">208  |</a> 
<a name="line209">209  |</a> /* check that we're not complete, or in error state.  in a valid state
<a name="line210">210  |</a>  * to be generating */
<a name="line211">211  |</a> #define ENSURE_VALID_STATE                        \
<a name="line212">212  |</a>     if (g-&gt;state[g-&gt;depth] == yajl_gen_error) {   \
<a name="line213">213  |</a>         return yajl_gen_in_error_state;                     \
<a name="line214">214  |</a>     } else if (g-&gt;state[g-&gt;depth] == yajl_gen_complete) {   \
<a name="line215">215  |</a>         return yajl_gen_generation_complete;                \
<a name="line216">216  |</a>     }
<a name="line217">217  |</a> 
<a name="line218">218  |</a> #define INCREMENT_DEPTH                                                 \
<a name="line219">219  |</a>     if (++(g-&gt;depth) &gt;= YAJL_MAX_DEPTH) {                               \
<a name="line220">220  |</a>         return yajl_max_depth_exceeded;                                 \
<a name="line221">221  |</a>     }
<a name="line222">222  |</a> 
<a name="line223">223  |</a> #define DECREMENT_DEPTH                                                 \
<a name="line224">224  |</a>     if (--(g-&gt;depth) &gt;= YAJL_MAX_DEPTH) {                               \
<a name="line225">225  |</a>         return yajl_gen_generation_complete;                            \
<a name="line226">226  |</a>     }
<a name="line227">227  |</a> 
<a name="line228">228  |</a> 
<a name="line229">229  |</a> #define APPENDED_ATOM \
<a name="line230">230  |</a>     switch (g-&gt;state[g-&gt;depth]) {                   \
<a name="line231">231  |</a>         case yajl_gen_start:                        \
<a name="line232">232  |</a>             g-&gt;state[g-&gt;depth] = yajl_gen_complete; \
<a name="line233">233  |</a>             break;                                  \
<a name="line234">234  |</a>         case yajl_gen_map_start:                    \
<a name="line235">235  |</a>         case yajl_gen_map_key:                      \
<a name="line236">236  |</a>             g-&gt;state[g-&gt;depth] = yajl_gen_map_val;  \
<a name="line237">237  |</a>             break;                                  \
<a name="line238">238  |</a>         case yajl_gen_array_start:                  \
<a name="line239">239  |</a>             g-&gt;state[g-&gt;depth] = yajl_gen_in_array; \
<a name="line240">240  |</a>             break;                                  \
<a name="line241">241  |</a>         case yajl_gen_map_val:                      \
<a name="line242">242  |</a>             g-&gt;state[g-&gt;depth] = yajl_gen_map_key;  \
<a name="line243">243  |</a>             break;                                  \
<a name="line244">244  |</a>         default:                                    \
<a name="line245">245  |</a>             break;                                  \
<a name="line246">246  |</a>     }
<a name="line247">247  |</a> 
<a name="line248">248  |</a> #define FINAL_NEWLINE                                                   \
<a name="line249">249  |</a>     if ((g-&gt;flags &amp; yajl_gen_beautify) &amp;&amp; g-&gt;state[g-&gt;depth] == yajl_gen_complete) { \
<a name="line250">250  |</a>         g-&gt;print(g-&gt;ctx, "\n", (size_t) 1);                             \
<a name="line251">251  |</a>     }
<a name="line252">252  |</a> 
<a name="line253">253  |</a> yajl_gen_status
<a name="line254">254  |</a> yajl_gen_integer(yajl_gen g, long long int number)
<a name="line255">255  |</a> {
<a name="line256">256  |</a>     char i[32];
<a name="line257">257  |</a>     int len;
<a name="line258">258  |</a> 
<a name="line259">259  |</a>     ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;
<a name="line260">260  |</a>     len = sprintf(i, "%lld", number);
<a name="line261">261  |</a>     if (len &lt; 0) {                     /* highly unlikely, perhaps impossible */
<a name="line262">262  |</a>         return yajl_gen_invalid_number;
<a name="line263">263  |</a>     }
<a name="line264">264  |</a>     g-&gt;print(g-&gt;ctx, i, (size_t) len);
<a name="line265">265  |</a>     APPENDED_ATOM;
<a name="line266">266  |</a>     FINAL_NEWLINE;
<a name="line267">267  |</a>     return yajl_gen_status_ok;
<a name="line268">268  |</a> }
<a name="line269">269  |</a> 
<a name="line270">270  |</a> #if defined(_WIN32) || defined(WIN32)
<a name="line271">271  |</a> #include &lt;float.h&gt;
<a name="line272">272  |</a> #define isnan _isnan
<a name="line273">273  |</a> #define isinf !_finite
<a name="line274">274  |</a> #endif
<a name="line275">275  |</a> 
<a name="line276">276  |</a> #if !defined(DBL_DIG)
<a name="line277">277  |</a> # if defined(__DBL_DIG__)
<a name="line278">278  |</a> #  define DBL_DIG	__DBL_DIG__
<a name="line279">279  |</a> # else
<a name="line280">280  |</a> #  define DBL_DIG	15		/* assumes binary64 IEEE 754 double */
<a name="line281">281  |</a> # endif
<a name="line282">282  |</a> #endif
<a name="line283">283  |</a> 
<a name="line284">284  |</a> /*+
<a name="line285">285  |</a>  *  generate a floating point number.  number may not be infinity or
<a name="line286">286  |</a>  *  NaN, as these have no representation in JSON.  In these cases the
<a name="line287">287  |</a>  *  generator will return 'yajl_gen_invalid_number'
<a name="line288">288  |</a>  +*/
<a name="line289">289  |</a> yajl_gen_status
<a name="line290">290  |</a> yajl_gen_double(yajl_gen g, double number)
<a name="line291">291  |</a> {
<a name="line292">292  |</a>     char i[32];
<a name="line293">293  |</a>     int len;
<a name="line294">294  |</a> 
<a name="line295">295  |</a>     ENSURE_VALID_STATE; ENSURE_NOT_KEY;
<a name="line296">296  |</a>     if (isnan(number) || isinf(number)) return yajl_gen_invalid_number;
<a name="line297">297  |</a>     INSERT_SEP; INSERT_WHITESPACE;
<a name="line298">298  |</a>     len = sprintf(i, "%.*g", DBL_DIG, number); /* xxx in theory we could/should
<a name="line299">299  |</a>                                                 * use DBL_DECIMAL_DIG for pure
<a name="line300">300  |</a>                                                 * serialization, but what about
<a name="line301">301  |</a>                                                 * to JSON readers that might not
<a name="line302">302  |</a>                                                 * be using IEEE 754 binary64 for
<a name="line303">303  |</a>                                                 * numbers? */
<a name="line304">304  |</a>     if (len &lt; 0) {                    /* highly unlikely, or even impossible? */
<a name="line305">305  |</a>         return yajl_gen_invalid_number;
<a name="line306">306  |</a>     }
<a name="line307">307  |</a>     /*
<a name="line308">308  |</a>      * xxx perhaps forcing decimal notation should be controlled by a
<a name="line309">309  |</a>      * runtime-configurable option?
<a name="line310">310  |</a>      */
<a name="line311">311  |</a>     if (strspn(i, "0123456789-") == strlen(i)) {
<a name="line312">312  |</a>         strcat(i, ".0");
<a name="line313">313  |</a>     }
<a name="line314">314  |</a>     g-&gt;print(g-&gt;ctx, i, (size_t) len);
<a name="line315">315  |</a>     APPENDED_ATOM;
<a name="line316">316  |</a>     FINAL_NEWLINE;
<a name="line317">317  |</a>     return yajl_gen_status_ok;
<a name="line318">318  |</a> }
<a name="line319">319  |</a> 
<a name="line320">320  |</a> yajl_gen_status
<a name="line321">321  |</a> yajl_gen_number(yajl_gen g, const char * s, size_t l)
<a name="line322">322  |</a> {
<a name="line323">323  |</a>     ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;
<a name="line324">324  |</a>     g-&gt;print(g-&gt;ctx, s, l);
<a name="line325">325  |</a>     APPENDED_ATOM;
<a name="line326">326  |</a>     FINAL_NEWLINE;
<a name="line327">327  |</a>     return yajl_gen_status_ok;
<a name="line328">328  |</a> }
<a name="line329">329  |</a> 
<a name="line330">330  |</a> yajl_gen_status
<a name="line331">331  |</a> yajl_gen_string(yajl_gen g, const unsigned char * str,
<a name="line332">332  |</a>                 size_t len)
<a name="line333">333  |</a> {
<a name="line334">334  |</a>     // if validation is enabled, check that the string is valid utf8
<a name="line335">335  |</a>     // XXX: This checking could be done a little faster, in the same pass as
<a name="line336">336  |</a>     // the string encoding
<a name="line337">337  |</a>     if (g-&gt;flags &amp; yajl_gen_validate_utf8) {
<a name="line338">338  |</a>         if (!yajl_string_validate_utf8(str, len)) {
<a name="line339">339  |</a>             return yajl_gen_invalid_string;
<a name="line340">340  |</a>         }
<a name="line341">341  |</a>     }
<a name="line342">342  |</a>     ENSURE_VALID_STATE; INSERT_SEP; INSERT_WHITESPACE;
<a name="line343">343  |</a>     g-&gt;print(g-&gt;ctx, "\"", (size_t) 1);
<a name="line344">344  |</a>     yajl_string_encode(g-&gt;print, g-&gt;ctx, str, len, g-&gt;flags &amp; yajl_gen_escape_solidus);
<a name="line345">345  |</a>     g-&gt;print(g-&gt;ctx, "\"", (size_t) 1);
<a name="line346">346  |</a>     APPENDED_ATOM;
<a name="line347">347  |</a>     FINAL_NEWLINE;
<a name="line348">348  |</a>     return yajl_gen_status_ok;
<a name="line349">349  |</a> }
<a name="line350">350  |</a> 
<a name="line351">351  |</a> yajl_gen_status
<a name="line352">352  |</a> yajl_gen_null(yajl_gen g)
<a name="line353">353  |</a> {
<a name="line354">354  |</a>     ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;
<a name="line355">355  |</a>     g-&gt;print(g-&gt;ctx, "null", strlen("null"));
<a name="line356">356  |</a>     APPENDED_ATOM;
<a name="line357">357  |</a>     FINAL_NEWLINE;
<a name="line358">358  |</a>     return yajl_gen_status_ok;
<a name="line359">359  |</a> }
<a name="line360">360  |</a> 
<a name="line361">361  |</a> yajl_gen_status
<a name="line362">362  |</a> yajl_gen_bool(yajl_gen g, int boolean)
<a name="line363">363  |</a> {
<a name="line364">364  |</a>     const char * val = boolean ? "true" : "false";
<a name="line365">365  |</a> 
<a name="line366">366  |</a>     ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;
<a name="line367">367  |</a>     g-&gt;print(g-&gt;ctx, val, (size_t)strlen(val));
<a name="line368">368  |</a>     APPENDED_ATOM;
<a name="line369">369  |</a>     FINAL_NEWLINE;
<a name="line370">370  |</a>     return yajl_gen_status_ok;
<a name="line371">371  |</a> }
<a name="line372">372  |</a> 
<a name="line373">373  |</a> yajl_gen_status
<a name="line374">374  |</a> yajl_gen_map_open(yajl_gen g)
<a name="line375">375  |</a> {
<a name="line376">376  |</a>     ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;
<a name="line377">377  |</a>     INCREMENT_DEPTH;
<a name="line378">378  |</a> 
<a name="line379">379  |</a>     g-&gt;state[g-&gt;depth] = yajl_gen_map_start;
<a name="line380">380  |</a>     g-&gt;print(g-&gt;ctx, "{", (size_t) 1);
<a name="line381">381  |</a>     if ((g-&gt;flags &amp; yajl_gen_beautify)) {
<a name="line382">382  |</a>         g-&gt;print(g-&gt;ctx, "\n", (size_t) 1);
<a name="line383">383  |</a>     }
<a name="line384">384  |</a>     FINAL_NEWLINE;
<a name="line385">385  |</a>     return yajl_gen_status_ok;
<a name="line386">386  |</a> }
<a name="line387">387  |</a> 
<a name="line388">388  |</a> yajl_gen_status
<a name="line389">389  |</a> yajl_gen_map_close(yajl_gen g)
<a name="line390">390  |</a> {
<a name="line391">391  |</a>     ENSURE_VALID_STATE;
<a name="line392">392  |</a>     DECREMENT_DEPTH;
<a name="line393">393  |</a> 
<a name="line394">394  |</a>     if ((g-&gt;flags &amp; yajl_gen_beautify)) {
<a name="line395">395  |</a>         g-&gt;print(g-&gt;ctx, "\n", (size_t) 1);
<a name="line396">396  |</a>     }
<a name="line397">397  |</a>     APPENDED_ATOM;
<a name="line398">398  |</a>     INSERT_WHITESPACE;
<a name="line399">399  |</a>     g-&gt;print(g-&gt;ctx, "}", (size_t) 1);
<a name="line400">400  |</a>     FINAL_NEWLINE;
<a name="line401">401  |</a>     return yajl_gen_status_ok;
<a name="line402">402  |</a> }
<a name="line403">403  |</a> 
<a name="line404">404  |</a> yajl_gen_status
<a name="line405">405  |</a> yajl_gen_array_open(yajl_gen g)
<a name="line406">406  |</a> {
<a name="line407">407  |</a>     ENSURE_VALID_STATE; ENSURE_NOT_KEY; INSERT_SEP; INSERT_WHITESPACE;
<a name="line408">408  |</a>     INCREMENT_DEPTH;
<a name="line409">409  |</a>     g-&gt;state[g-&gt;depth] = yajl_gen_array_start;
<a name="line410">410  |</a>     g-&gt;print(g-&gt;ctx, "[", (size_t) 1);
<a name="line411">411  |</a>     if ((g-&gt;flags &amp; yajl_gen_beautify)) {
<a name="line412">412  |</a>         g-&gt;print(g-&gt;ctx, "\n", (size_t) 1);
<a name="line413">413  |</a>     }
<a name="line414">414  |</a>     FINAL_NEWLINE;
<a name="line415">415  |</a>     return yajl_gen_status_ok;
<a name="line416">416  |</a> }
<a name="line417">417  |</a> 
<a name="line418">418  |</a> yajl_gen_status
<a name="line419">419  |</a> yajl_gen_array_close(yajl_gen g)
<a name="line420">420  |</a> {
<a name="line421">421  |</a>     ENSURE_VALID_STATE;
<a name="line422">422  |</a>     DECREMENT_DEPTH;
<a name="line423">423  |</a>     if ((g-&gt;flags &amp; yajl_gen_beautify)) {
<a name="line424">424  |</a>         g-&gt;print(g-&gt;ctx, "\n", (size_t) 1);
<a name="line425">425  |</a>     }
<a name="line426">426  |</a>     APPENDED_ATOM;
<a name="line427">427  |</a>     INSERT_WHITESPACE;
<a name="line428">428  |</a>     g-&gt;print(g-&gt;ctx, "]", (size_t) 1);
<a name="line429">429  |</a>     FINAL_NEWLINE;
<a name="line430">430  |</a>     return yajl_gen_status_ok;
<a name="line431">431  |</a> }
<a name="line432">432  |</a> 
<a name="line433">433  |</a> /*+
<a name="line434">434  |</a>  *  access the null terminated generator buffer.  If incrementally
<a name="line435">435  |</a>  *  outputing JSON, one should call yajl_gen_clear to clear the
<a name="line436">436  |</a>  *  buffer.  This allows stream generation.
<a name="line437">437  |</a>  +*/
<a name="line438">438  |</a> yajl_gen_status
<a name="line439">439  |</a> yajl_gen_get_buf(yajl_gen g, const unsigned char ** buf,
<a name="line440">440  |</a>                  size_t * len)
<a name="line441">441  |</a> {
<a name="line442">442  |</a>     if (g-&gt;print != (yajl_print_t) &amp;yajl_buf_append) {
<a name="line443">443  |</a>         return yajl_gen_no_buf;
<a name="line444">444  |</a>     }
<a name="line445">445  |</a>     *buf = yajl_buf_data((yajl_buf) g-&gt;ctx);
<a name="line446">446  |</a>     *len = yajl_buf_len((yajl_buf) g-&gt;ctx);
<a name="line447">447  |</a>     return yajl_gen_status_ok;
<a name="line448">448  |</a> }
<a name="line449">449  |</a> 
<a name="line450">450  |</a> 
<a name="line451">451  |</a> /*+
<a name="line452">452  |</a>  *  clear yajl's output buffer, but maintain all internal generation
<a name="line453">453  |</a>  *  state.  This function will not "reset" the generator state, and is
<a name="line454">454  |</a>  *  intended to enable incremental JSON outputing.
<a name="line455">455  |</a>  +*/
<a name="line456">456  |</a> void
<a name="line457">457  |</a> yajl_gen_clear(yajl_gen g)
<a name="line458">458  |</a> {
<a name="line459">459  |</a>     if (g-&gt;print == (yajl_print_t) &amp;yajl_buf_append) {
<a name="line460">460  |</a>         yajl_buf_clear((yajl_buf) g-&gt;ctx);
<a name="line461">461  |</a>     }
<a name="line462">462  |</a> }
</pre>

</BODY>
</HTML>
