<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<!-- This HTML file generated by cxref (version 1.6d). -->
<!-- cxref program (c) Andrew M. Bishop 1995-2011. -->

<!--
Cxref: cxref -warn-all -xref-all -block-comments -O/work/woods/f-yajl/build/work/woods/f-yajl/doc/html -Nyajl -html -html-src -I/work/woods/f-yajl/src -I/work/woods/f-yajl/build/work/woods/f-yajl/./src-CPP "cc -E -CC -x c" src/yajl_tree.c
CPP  : cc -E -CC -x c -Isrc -Ibuild/work/woods/f-yajl/./src
-->

<HTML>

<HEAD>
<TITLE>Source File src/yajl_tree.c</TITLE>
<LINK rel="stylesheet" href="../cxref.css" type="text/css">
</HEAD>

<BODY>

<pre>
<a name="line1">1    |</a> /*
<a name="line2">2    |</a>  * Copyright (c) 2010-2011  Florian Forster  &lt;ff at octo.it&gt;
<a name="line3">3    |</a>  *
<a name="line4">4    |</a>  * Permission to use, copy, modify, and/or distribute this software for any
<a name="line5">5    |</a>  * purpose with or without fee is hereby granted, provided that the above
<a name="line6">6    |</a>  * copyright notice and this permission notice appear in all copies.
<a name="line7">7    |</a>  *
<a name="line8">8    |</a>  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
<a name="line9">9    |</a>  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
<a name="line10">10   |</a>  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
<a name="line11">11   |</a>  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
<a name="line12">12   |</a>  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
<a name="line13">13   |</a>  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
<a name="line14">14   |</a>  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
<a name="line15">15   |</a>  */
<a name="line16">16   |</a> 
<a name="line17">17   |</a> /**
<a name="line18">18   |</a>  * Parses JSON data and returns the data in tree form.
<a name="line19">19   |</a>  *
<a name="line20">20   |</a>  * Writtan by Florian Forster
<a name="line21">21   |</a>  *
<a name="line22">22   |</a>  * August 2010
<a name="line23">23   |</a>  *
<a name="line24">24   |</a>  * This interface makes quick parsing and extraction of smallish JSON docs
<a name="line25">25   |</a>  * trivial, as shown in the following example:
<a name="line26">26   |</a>  *
<a name="line27">27   |</a>  * +html+ &lt;a href="../example/parse_config.c.html#file"&gt;example/parse_config.c&lt;/a&gt;&lt;br&gt;
<a name="line28">28   |</a>  **/
<a name="line29">29   |</a> 
<a name="line30">30   |</a> #include &lt;stdint.h&gt;
<a name="line31">31   |</a> #include &lt;stdio.h&gt;
<a name="line32">32   |</a> #include &lt;string.h&gt;
<a name="line33">33   |</a> #include &lt;stdlib.h&gt;
<a name="line34">34   |</a> #include &lt;errno.h&gt;
<a name="line35">35   |</a> #include &lt;assert.h&gt;
<a name="line36">36   |</a> 
<a name="line37">37   |</a> #include "yajl/yajl_tree.h"
<a name="line38">38   |</a> #include "yajl/yajl_parse.h"
<a name="line39">39   |</a> 
<a name="line40">40   |</a> #include "yajl_parser.h"
<a name="line41">41   |</a> 
<a name="line42">42   |</a> #if defined(_WIN32) || defined(WIN32)
<a name="line43">43   |</a> #define snprintf sprintf_s
<a name="line44">44   |</a> #endif
<a name="line45">45   |</a> 
<a name="line46">46   |</a> #define STATUS_CONTINUE 1
<a name="line47">47   |</a> #define STATUS_ABORT    0
<a name="line48">48   |</a> 
<a name="line49">49   |</a> struct stack_elem_s;
<a name="line50">50   |</a> typedef struct stack_elem_s stack_elem_t;
<a name="line51">51   |</a> struct stack_elem_s
<a name="line52">52   |</a> {
<a name="line53">53   |</a>     char * key;
<a name="line54">54   |</a>     yajl_val value;
<a name="line55">55   |</a>     stack_elem_t *next;
<a name="line56">56   |</a> };
<a name="line57">57   |</a> 
<a name="line58">58   |</a> struct context_s
<a name="line59">59   |</a> {
<a name="line60">60   |</a>     stack_elem_t *stack;
<a name="line61">61   |</a>     yajl_val root;
<a name="line62">62   |</a>     char *errbuf;
<a name="line63">63   |</a>     size_t errbuf_size;
<a name="line64">64   |</a> };
<a name="line65">65   |</a> typedef struct context_s context_t;
<a name="line66">66   |</a> 
<a name="line67">67   |</a> #define RETURN_ERROR(ctx,retval,...) {                                  \
<a name="line68">68   |</a>         if ((ctx)-&gt;errbuf != NULL)                                      \
<a name="line69">69   |</a>             snprintf ((ctx)-&gt;errbuf, (ctx)-&gt;errbuf_size, __VA_ARGS__);  \
<a name="line70">70   |</a>         return (retval);                                                \
<a name="line71">71   |</a>     }
<a name="line72">72   |</a> 
<a name="line73">73   |</a> static yajl_val value_alloc (yajl_type type)
<a name="line74">74   |</a> {
<a name="line75">75   |</a>     yajl_val v;
<a name="line76">76   |</a> 
<a name="line77">77   |</a>     v = malloc (sizeof (*v));
<a name="line78">78   |</a>     if (v == NULL) return (NULL);
<a name="line79">79   |</a>     memset (v, 0, sizeof (*v));
<a name="line80">80   |</a>     v-&gt;type = type;
<a name="line81">81   |</a> 
<a name="line82">82   |</a>     return (v);
<a name="line83">83   |</a> }
<a name="line84">84   |</a> 
<a name="line85">85   |</a> static void yajl_object_free (yajl_val v)
<a name="line86">86   |</a> {
<a name="line87">87   |</a>     size_t i;
<a name="line88">88   |</a> 
<a name="line89">89   |</a>     if (!YAJL_IS_OBJECT(v)) return;
<a name="line90">90   |</a> 
<a name="line91">91   |</a>     for (i = 0; i &lt; v-&gt;u.object.len; i++)
<a name="line92">92   |</a>     {
<a name="line93">93   |</a>         /* __UNCONST() */
<a name="line94">94   |</a>         free((void *)(uintmax_t)(const void *) v-&gt;u.object.keys[i]);
<a name="line95">95   |</a>         v-&gt;u.object.keys[i] = NULL;
<a name="line96">96   |</a>         yajl_tree_free (v-&gt;u.object.values[i]);
<a name="line97">97   |</a>         v-&gt;u.object.values[i] = NULL;
<a name="line98">98   |</a>     }
<a name="line99">99   |</a> 
<a name="line100">100  |</a>     free((void*) v-&gt;u.object.keys);
<a name="line101">101  |</a>     free(v-&gt;u.object.values);
<a name="line102">102  |</a>     free(v);
<a name="line103">103  |</a> }
<a name="line104">104  |</a> 
<a name="line105">105  |</a> static void yajl_array_free (yajl_val v)
<a name="line106">106  |</a> {
<a name="line107">107  |</a>     size_t i;
<a name="line108">108  |</a> 
<a name="line109">109  |</a>     if (!YAJL_IS_ARRAY(v)) return;
<a name="line110">110  |</a> 
<a name="line111">111  |</a>     for (i = 0; i &lt; v-&gt;u.array.len; i++)
<a name="line112">112  |</a>     {
<a name="line113">113  |</a>         yajl_tree_free (v-&gt;u.array.values[i]);
<a name="line114">114  |</a>         v-&gt;u.array.values[i] = NULL;
<a name="line115">115  |</a>     }
<a name="line116">116  |</a> 
<a name="line117">117  |</a>     free(v-&gt;u.array.values);
<a name="line118">118  |</a>     free(v);
<a name="line119">119  |</a> }
<a name="line120">120  |</a> 
<a name="line121">121  |</a> /*
<a name="line122">122  |</a>  * Parsing nested objects and arrays is implemented using a stack. When a new
<a name="line123">123  |</a>  * object or array starts (a curly or a square opening bracket is read), an
<a name="line124">124  |</a>  * appropriate value is pushed on the stack. When the end of the object is
<a name="line125">125  |</a>  * reached (an appropriate closing bracket has been read), the value is popped
<a name="line126">126  |</a>  * off the stack and added to the enclosing object using "context_add_value".
<a name="line127">127  |</a>  */
<a name="line128">128  |</a> static int context_push(context_t *ctx, yajl_val v)
<a name="line129">129  |</a> {
<a name="line130">130  |</a>     stack_elem_t *stack;
<a name="line131">131  |</a> 
<a name="line132">132  |</a>     stack = malloc (sizeof (*stack));
<a name="line133">133  |</a>     if (stack == NULL)
<a name="line134">134  |</a>         RETURN_ERROR (ctx, ENOMEM, "Out of memory");
<a name="line135">135  |</a>     memset (stack, 0, sizeof (*stack));
<a name="line136">136  |</a> 
<a name="line137">137  |</a>     assert ((ctx-&gt;stack == NULL)
<a name="line138">138  |</a>             || YAJL_IS_OBJECT (v)
<a name="line139">139  |</a>             || YAJL_IS_ARRAY (v));
<a name="line140">140  |</a> 
<a name="line141">141  |</a>     stack-&gt;value = v;
<a name="line142">142  |</a>     stack-&gt;next = ctx-&gt;stack;
<a name="line143">143  |</a>     ctx-&gt;stack = stack;
<a name="line144">144  |</a> 
<a name="line145">145  |</a>     return (0);
<a name="line146">146  |</a> }
<a name="line147">147  |</a> 
<a name="line148">148  |</a> static yajl_val context_pop(context_t *ctx)
<a name="line149">149  |</a> {
<a name="line150">150  |</a>     stack_elem_t *stack;
<a name="line151">151  |</a>     yajl_val v;
<a name="line152">152  |</a> 
<a name="line153">153  |</a>     if (ctx-&gt;stack == NULL)
<a name="line154">154  |</a>         RETURN_ERROR (ctx, NULL, "context_pop: "
<a name="line155">155  |</a>                       "Bottom of stack reached prematurely");
<a name="line156">156  |</a> 
<a name="line157">157  |</a>     stack = ctx-&gt;stack;
<a name="line158">158  |</a>     ctx-&gt;stack = stack-&gt;next;
<a name="line159">159  |</a> 
<a name="line160">160  |</a>     v = stack-&gt;value;
<a name="line161">161  |</a> 
<a name="line162">162  |</a>     free (stack);
<a name="line163">163  |</a> 
<a name="line164">164  |</a>     return (v);
<a name="line165">165  |</a> }
<a name="line166">166  |</a> 
<a name="line167">167  |</a> static int object_add_keyval(context_t *ctx,
<a name="line168">168  |</a>                              yajl_val obj, char *key, yajl_val value)
<a name="line169">169  |</a> {
<a name="line170">170  |</a>     const char **tmpk;
<a name="line171">171  |</a>     yajl_val *tmpv;
<a name="line172">172  |</a> 
<a name="line173">173  |</a>     /* We're checking for NULL in "context_add_value" or its callers. */
<a name="line174">174  |</a>     assert (ctx != NULL);
<a name="line175">175  |</a>     assert (obj != NULL);
<a name="line176">176  |</a>     assert (key != NULL);
<a name="line177">177  |</a>     assert (value != NULL);
<a name="line178">178  |</a> 
<a name="line179">179  |</a>     /* We're assuring that "obj" is an object in "context_add_value". */
<a name="line180">180  |</a>     assert(YAJL_IS_OBJECT(obj));
<a name="line181">181  |</a> 
<a name="line182">182  |</a>     tmpk = realloc((void *) obj-&gt;u.object.keys, sizeof(*(obj-&gt;u.object.keys)) * (obj-&gt;u.object.len + 1));
<a name="line183">183  |</a>     if (tmpk == NULL)
<a name="line184">184  |</a>         RETURN_ERROR(ctx, ENOMEM, "Out of memory");
<a name="line185">185  |</a>     obj-&gt;u.object.keys = tmpk;
<a name="line186">186  |</a> 
<a name="line187">187  |</a>     tmpv = realloc(obj-&gt;u.object.values, sizeof (*obj-&gt;u.object.values) * (obj-&gt;u.object.len + 1));
<a name="line188">188  |</a>     if (tmpv == NULL)
<a name="line189">189  |</a>         RETURN_ERROR(ctx, ENOMEM, "Out of memory");
<a name="line190">190  |</a>     obj-&gt;u.object.values = tmpv;
<a name="line191">191  |</a> 
<a name="line192">192  |</a>     obj-&gt;u.object.keys[obj-&gt;u.object.len] = key;
<a name="line193">193  |</a>     obj-&gt;u.object.values[obj-&gt;u.object.len] = value;
<a name="line194">194  |</a>     obj-&gt;u.object.len++;
<a name="line195">195  |</a> 
<a name="line196">196  |</a>     return (0);
<a name="line197">197  |</a> }
<a name="line198">198  |</a> 
<a name="line199">199  |</a> static int array_add_value (context_t *ctx,
<a name="line200">200  |</a>                             yajl_val array, yajl_val value)
<a name="line201">201  |</a> {
<a name="line202">202  |</a>     yajl_val *tmp;
<a name="line203">203  |</a> 
<a name="line204">204  |</a>     /* We're checking for NULL pointers in "context_add_value" or its
<a name="line205">205  |</a>      * callers. */
<a name="line206">206  |</a>     assert (ctx != NULL);
<a name="line207">207  |</a>     assert (array != NULL);
<a name="line208">208  |</a>     assert (value != NULL);
<a name="line209">209  |</a> 
<a name="line210">210  |</a>     /* "context_add_value" will only call us with array values. */
<a name="line211">211  |</a>     assert(YAJL_IS_ARRAY(array));
<a name="line212">212  |</a> 
<a name="line213">213  |</a>     tmp = realloc(array-&gt;u.array.values,
<a name="line214">214  |</a>                   sizeof(*(array-&gt;u.array.values)) * (array-&gt;u.array.len + 1));
<a name="line215">215  |</a>     if (tmp == NULL)
<a name="line216">216  |</a>         RETURN_ERROR(ctx, ENOMEM, "Out of memory");
<a name="line217">217  |</a>     array-&gt;u.array.values = tmp;
<a name="line218">218  |</a>     array-&gt;u.array.values[array-&gt;u.array.len] = value;
<a name="line219">219  |</a>     array-&gt;u.array.len++;
<a name="line220">220  |</a> 
<a name="line221">221  |</a>     return 0;
<a name="line222">222  |</a> }
<a name="line223">223  |</a> 
<a name="line224">224  |</a> /*
<a name="line225">225  |</a>  * Add a value to the value on top of the stack or the "root" member in the
<a name="line226">226  |</a>  * context if the end of the parsing process is reached.
<a name="line227">227  |</a>  */
<a name="line228">228  |</a> static int context_add_value (context_t *ctx, yajl_val v)
<a name="line229">229  |</a> {
<a name="line230">230  |</a>     /* We're checking for NULL values in all the calling functions. */
<a name="line231">231  |</a>     assert (ctx != NULL);
<a name="line232">232  |</a>     assert (v != NULL);
<a name="line233">233  |</a> 
<a name="line234">234  |</a>     /*
<a name="line235">235  |</a>      * There are three valid states in which this function may be called:
<a name="line236">236  |</a>      *   - There is no value on the stack =&gt; This is the only value. This is the
<a name="line237">237  |</a>      *     last step done when parsing a document. We assign the value to the
<a name="line238">238  |</a>      *     "root" member and return.
<a name="line239">239  |</a>      *   - The value on the stack is an object. In this case store the key on the
<a name="line240">240  |</a>      *     stack or, if the key has already been read, add key and value to the
<a name="line241">241  |</a>      *     object.
<a name="line242">242  |</a>      *   - The value on the stack is an array. In this case simply add the value
<a name="line243">243  |</a>      *     and return.
<a name="line244">244  |</a>      */
<a name="line245">245  |</a>     if (ctx-&gt;stack == NULL)
<a name="line246">246  |</a>     {
<a name="line247">247  |</a>         assert (ctx-&gt;root == NULL);
<a name="line248">248  |</a>         ctx-&gt;root = v;
<a name="line249">249  |</a>         return (0);
<a name="line250">250  |</a>     }
<a name="line251">251  |</a>     else if (YAJL_IS_OBJECT (ctx-&gt;stack-&gt;value))
<a name="line252">252  |</a>     {
<a name="line253">253  |</a>         if (ctx-&gt;stack-&gt;key == NULL)
<a name="line254">254  |</a>         {
<a name="line255">255  |</a>             if (!YAJL_IS_STRING (v))
<a name="line256">256  |</a>                 RETURN_ERROR (ctx, EINVAL, "context_add_value: "
<a name="line257">257  |</a>                               "Object key is not a string (%#04x)",
<a name="line258">258  |</a>                               v-&gt;type);
<a name="line259">259  |</a> 
<a name="line260">260  |</a>             ctx-&gt;stack-&gt;key = v-&gt;u.string;
<a name="line261">261  |</a>             v-&gt;u.string = NULL;
<a name="line262">262  |</a>             free(v);
<a name="line263">263  |</a>             return (0);
<a name="line264">264  |</a>         }
<a name="line265">265  |</a>         else /* if (ctx-&gt;key != NULL) */
<a name="line266">266  |</a>         {
<a name="line267">267  |</a>             char * key;
<a name="line268">268  |</a> 
<a name="line269">269  |</a>             key = ctx-&gt;stack-&gt;key;
<a name="line270">270  |</a>             ctx-&gt;stack-&gt;key = NULL;
<a name="line271">271  |</a>             return (object_add_keyval (ctx, ctx-&gt;stack-&gt;value, key, v));
<a name="line272">272  |</a>         }
<a name="line273">273  |</a>     }
<a name="line274">274  |</a>     else if (YAJL_IS_ARRAY (ctx-&gt;stack-&gt;value))
<a name="line275">275  |</a>     {
<a name="line276">276  |</a>         return (array_add_value (ctx, ctx-&gt;stack-&gt;value, v));
<a name="line277">277  |</a>     }
<a name="line278">278  |</a>     else
<a name="line279">279  |</a>     {
<a name="line280">280  |</a>         RETURN_ERROR (ctx, EINVAL, "context_add_value: Cannot add value to "
<a name="line281">281  |</a>                       "a value of type %#04x (not a composite type)",
<a name="line282">282  |</a>                       ctx-&gt;stack-&gt;value-&gt;type);
<a name="line283">283  |</a>     }
<a name="line284">284  |</a> }
<a name="line285">285  |</a> 
<a name="line286">286  |</a> static int handle_string (void *ctx,
<a name="line287">287  |</a>                           const unsigned char *string, size_t string_length)
<a name="line288">288  |</a> {
<a name="line289">289  |</a>     yajl_val v;
<a name="line290">290  |</a> 
<a name="line291">291  |</a>     v = value_alloc (yajl_t_string);
<a name="line292">292  |</a>     if (v == NULL)
<a name="line293">293  |</a>         RETURN_ERROR ((context_t *) ctx, STATUS_ABORT, "Out of memory");
<a name="line294">294  |</a> 
<a name="line295">295  |</a>     v-&gt;u.string = malloc (string_length + 1);
<a name="line296">296  |</a>     if (v-&gt;u.string == NULL)
<a name="line297">297  |</a>     {
<a name="line298">298  |</a>         free (v);
<a name="line299">299  |</a>         RETURN_ERROR ((context_t *) ctx, STATUS_ABORT, "Out of memory");
<a name="line300">300  |</a>     }
<a name="line301">301  |</a>     memcpy(v-&gt;u.string, string, string_length);
<a name="line302">302  |</a>     v-&gt;u.string[string_length] = 0;
<a name="line303">303  |</a> 
<a name="line304">304  |</a>     return ((context_add_value (ctx, v) == 0) ? STATUS_CONTINUE : STATUS_ABORT);
<a name="line305">305  |</a> }
<a name="line306">306  |</a> 
<a name="line307">307  |</a> static int handle_number (void *ctx, const char *string, size_t string_length)
<a name="line308">308  |</a> {
<a name="line309">309  |</a>     yajl_val v;
<a name="line310">310  |</a>     char *endptr;
<a name="line311">311  |</a> 
<a name="line312">312  |</a>     v = value_alloc(yajl_t_number);
<a name="line313">313  |</a>     if (v == NULL)
<a name="line314">314  |</a>         RETURN_ERROR((context_t *) ctx, STATUS_ABORT, "Out of memory");
<a name="line315">315  |</a> 
<a name="line316">316  |</a>     v-&gt;u.number.r = malloc(string_length + 1);
<a name="line317">317  |</a>     if (v-&gt;u.number.r == NULL)
<a name="line318">318  |</a>     {
<a name="line319">319  |</a>         free(v);
<a name="line320">320  |</a>         RETURN_ERROR((context_t *) ctx, STATUS_ABORT, "Out of memory");
<a name="line321">321  |</a>     }
<a name="line322">322  |</a>     memcpy(v-&gt;u.number.r, string, string_length);
<a name="line323">323  |</a>     v-&gt;u.number.r[string_length] = 0;
<a name="line324">324  |</a> 
<a name="line325">325  |</a>     v-&gt;u.number.flags = 0;
<a name="line326">326  |</a> 
<a name="line327">327  |</a>     errno = 0;
<a name="line328">328  |</a>     v-&gt;u.number.i = yajl_parse_integer((const unsigned char *) v-&gt;u.number.r,
<a name="line329">329  |</a>                                        strlen(v-&gt;u.number.r));
<a name="line330">330  |</a>     if (errno == 0)
<a name="line331">331  |</a>         v-&gt;u.number.flags |= YAJL_NUMBER_INT_VALID;
<a name="line332">332  |</a> 
<a name="line333">333  |</a>     endptr = NULL;
<a name="line334">334  |</a>     errno = 0;
<a name="line335">335  |</a>     v-&gt;u.number.d = strtod(v-&gt;u.number.r, &amp;endptr);
<a name="line336">336  |</a>     if ((errno == 0) &amp;&amp; (endptr != NULL) &amp;&amp; (*endptr == 0))
<a name="line337">337  |</a>         v-&gt;u.number.flags |= YAJL_NUMBER_DOUBLE_VALID;
<a name="line338">338  |</a> 
<a name="line339">339  |</a>     return ((context_add_value(ctx, v) == 0) ? STATUS_CONTINUE : STATUS_ABORT);
<a name="line340">340  |</a> }
<a name="line341">341  |</a> 
<a name="line342">342  |</a> static int handle_start_map (void *ctx)
<a name="line343">343  |</a> {
<a name="line344">344  |</a>     yajl_val v;
<a name="line345">345  |</a> 
<a name="line346">346  |</a>     v = value_alloc(yajl_t_object);
<a name="line347">347  |</a>     if (v == NULL)
<a name="line348">348  |</a>         RETURN_ERROR ((context_t *) ctx, STATUS_ABORT, "Out of memory");
<a name="line349">349  |</a> 
<a name="line350">350  |</a>     v-&gt;u.object.keys = NULL;
<a name="line351">351  |</a>     v-&gt;u.object.values = NULL;
<a name="line352">352  |</a>     v-&gt;u.object.len = 0;
<a name="line353">353  |</a> 
<a name="line354">354  |</a>     return ((context_push (ctx, v) == 0) ? STATUS_CONTINUE : STATUS_ABORT);
<a name="line355">355  |</a> }
<a name="line356">356  |</a> 
<a name="line357">357  |</a> static int handle_end_map (void *ctx)
<a name="line358">358  |</a> {
<a name="line359">359  |</a>     yajl_val v;
<a name="line360">360  |</a> 
<a name="line361">361  |</a>     v = context_pop (ctx);
<a name="line362">362  |</a>     if (v == NULL)
<a name="line363">363  |</a>         return (STATUS_ABORT);
<a name="line364">364  |</a> 
<a name="line365">365  |</a>     return ((context_add_value (ctx, v) == 0) ? STATUS_CONTINUE : STATUS_ABORT);
<a name="line366">366  |</a> }
<a name="line367">367  |</a> 
<a name="line368">368  |</a> static int handle_start_array (void *ctx)
<a name="line369">369  |</a> {
<a name="line370">370  |</a>     yajl_val v;
<a name="line371">371  |</a> 
<a name="line372">372  |</a>     v = value_alloc(yajl_t_array);
<a name="line373">373  |</a>     if (v == NULL)
<a name="line374">374  |</a>         RETURN_ERROR ((context_t *) ctx, STATUS_ABORT, "Out of memory");
<a name="line375">375  |</a> 
<a name="line376">376  |</a>     v-&gt;u.array.values = NULL;
<a name="line377">377  |</a>     v-&gt;u.array.len = 0;
<a name="line378">378  |</a> 
<a name="line379">379  |</a>     return ((context_push (ctx, v) == 0) ? STATUS_CONTINUE : STATUS_ABORT);
<a name="line380">380  |</a> }
<a name="line381">381  |</a> 
<a name="line382">382  |</a> static int handle_end_array (void *ctx)
<a name="line383">383  |</a> {
<a name="line384">384  |</a>     yajl_val v;
<a name="line385">385  |</a> 
<a name="line386">386  |</a>     v = context_pop (ctx);
<a name="line387">387  |</a>     if (v == NULL)
<a name="line388">388  |</a>         return (STATUS_ABORT);
<a name="line389">389  |</a> 
<a name="line390">390  |</a>     return ((context_add_value (ctx, v) == 0) ? STATUS_CONTINUE : STATUS_ABORT);
<a name="line391">391  |</a> }
<a name="line392">392  |</a> 
<a name="line393">393  |</a> static int handle_boolean (void *ctx, int boolean_value)
<a name="line394">394  |</a> {
<a name="line395">395  |</a>     yajl_val v;
<a name="line396">396  |</a> 
<a name="line397">397  |</a>     v = value_alloc (boolean_value ? yajl_t_true : yajl_t_false);
<a name="line398">398  |</a>     if (v == NULL)
<a name="line399">399  |</a>         RETURN_ERROR ((context_t *) ctx, STATUS_ABORT, "Out of memory");
<a name="line400">400  |</a> 
<a name="line401">401  |</a>     return ((context_add_value (ctx, v) == 0) ? STATUS_CONTINUE : STATUS_ABORT);
<a name="line402">402  |</a> }
<a name="line403">403  |</a> 
<a name="line404">404  |</a> static int handle_null (void *ctx)
<a name="line405">405  |</a> {
<a name="line406">406  |</a>     yajl_val v;
<a name="line407">407  |</a> 
<a name="line408">408  |</a>     v = value_alloc (yajl_t_null);
<a name="line409">409  |</a>     if (v == NULL)
<a name="line410">410  |</a>         RETURN_ERROR ((context_t *) ctx, STATUS_ABORT, "Out of memory");
<a name="line411">411  |</a> 
<a name="line412">412  |</a>     return ((context_add_value (ctx, v) == 0) ? STATUS_CONTINUE : STATUS_ABORT);
<a name="line413">413  |</a> }
<a name="line414">414  |</a> 
<a name="line415">415  |</a> /*
<a name="line416">416  |</a>  * Public functions
<a name="line417">417  |</a>  */
<a name="line418">418  |</a> /*+
<a name="line419">419  |</a>  * Parse a string.
<a name="line420">420  |</a>  *
<a name="line421">421  |</a>  * Parses a null-terminated string containing JSON data.
<a name="line422">422  |</a>  *
<a name="line423">423  |</a>  * Returns a pointer to a yajl_val object which is the top-level value (root of
<a name="line424">424  |</a>  * the parse tree) or NULL on error.
<a name="line425">425  |</a>  *
<a name="line426">426  |</a>  * The memory pointed to must be freed using yajl_tree_free().  In case of an
<a name="line427">427  |</a>  * error, a null terminated message describing the error in more detail is
<a name="line428">428  |</a>  * stored in error_buffer if it is not NULL.
<a name="line429">429  |</a>  +*/
<a name="line430">430  |</a> yajl_val yajl_tree_parse (const char *input, /*+ Pointer to a null-terminated
<a name="line431">431  |</a>                                               *  utf8 string containing JSON
<a name="line432">432  |</a>                                               *  data. +*/
<a name="line433">433  |</a>                           char *error_buffer, /*+ Pointer to a buffer in which
<a name="line434">434  |</a>                                                * an error message will be stored
<a name="line435">435  |</a>                                                * if yajl_tree_parse() fails, or
<a name="line436">436  |</a>                                                * NULL. The buffer will be
<a name="line437">437  |</a>                                                * initialized before parsing, so
<a name="line438">438  |</a>                                                * its content will be destroyed
<a name="line439">439  |</a>                                                * even if yajl_tree_parse()
<a name="line440">440  |</a>                                                * succeeds. +*/
<a name="line441">441  |</a>                           size_t error_buffer_size) /*+ Size of the memory area
<a name="line442">442  |</a>                                                      * pointed to by
<a name="line443">443  |</a>                                                      * error_buffer_size.  If
<a name="line444">444  |</a>                                                      * error_buffer_size is
<a name="line445">445  |</a>                                                      * NULL, this argument is
<a name="line446">446  |</a>                                                      * ignored. +*/
<a name="line447">447  |</a> {
<a name="line448">448  |</a>     /* pointers to parsing callbacks */
<a name="line449">449  |</a>     static const yajl_callbacks callbacks =
<a name="line450">450  |</a>         {
<a name="line451">451  |</a>             /* null        = */ handle_null,
<a name="line452">452  |</a>             /* boolean     = */ handle_boolean,
<a name="line453">453  |</a>             /* integer     = */ NULL,
<a name="line454">454  |</a>             /* double      = */ NULL,
<a name="line455">455  |</a>             /* number      = */ handle_number,
<a name="line456">456  |</a>             /* string      = */ handle_string,
<a name="line457">457  |</a>             /* start map   = */ handle_start_map,
<a name="line458">458  |</a>             /* map key     = */ handle_string,
<a name="line459">459  |</a>             /* end map     = */ handle_end_map,
<a name="line460">460  |</a>             /* start array = */ handle_start_array,
<a name="line461">461  |</a>             /* end array   = */ handle_end_array
<a name="line462">462  |</a>         };
<a name="line463">463  |</a> 
<a name="line464">464  |</a>     yajl_handle handle;
<a name="line465">465  |</a>     yajl_status status;
<a name="line466">466  |</a>     char * internal_err_str;
<a name="line467">467  |</a> 	context_t ctx = { NULL, NULL, NULL, 0 };
<a name="line468">468  |</a> 
<a name="line469">469  |</a> 	ctx.errbuf = error_buffer;
<a name="line470">470  |</a> 	ctx.errbuf_size = error_buffer_size;
<a name="line471">471  |</a> 
<a name="line472">472  |</a>     if (error_buffer != NULL)
<a name="line473">473  |</a>         memset (error_buffer, 0, error_buffer_size);
<a name="line474">474  |</a> 
<a name="line475">475  |</a>     handle = yajl_alloc (&amp;callbacks, NULL, &amp;ctx);
<a name="line476">476  |</a>     yajl_config(handle, yajl_allow_comments, 1);
<a name="line477">477  |</a> 
<a name="line478">478  |</a>     status = yajl_parse(handle,
<a name="line479">479  |</a>                         (const unsigned char *) input,
<a name="line480">480  |</a>                         strlen (input));
<a name="line481">481  |</a>     if (status != yajl_status_ok) {
<a name="line482">482  |</a>         if (error_buffer != NULL &amp;&amp; error_buffer_size &gt; 0) {
<a name="line483">483  |</a>                internal_err_str = (char *) yajl_get_error(handle, 1,
<a name="line484">484  |</a>                      (const unsigned char *) input,
<a name="line485">485  |</a>                      strlen(input));
<a name="line486">486  |</a>              snprintf(error_buffer, error_buffer_size, "%s", internal_err_str);
<a name="line487">487  |</a>              YA_FREE(&amp;(handle-&gt;alloc), internal_err_str);
<a name="line488">488  |</a>         }
<a name="line489">489  |</a>         while (ctx.stack) {
<a name="line490">490  |</a>             yajl_tree_free(context_pop(&amp;ctx));
<a name="line491">491  |</a>         }
<a name="line492">492  |</a>         yajl_free (handle);
<a name="line493">493  |</a>         return NULL;
<a name="line494">494  |</a>     }
<a name="line495">495  |</a>     yajl_complete_parse (handle);
<a name="line496">496  |</a> 
<a name="line497">497  |</a>     yajl_free (handle);
<a name="line498">498  |</a>     return (ctx.root);
<a name="line499">499  |</a> }
<a name="line500">500  |</a> 
<a name="line501">501  |</a> /*+
<a name="line502">502  |</a>  * Access a nested value inside a tree.
<a name="line503">503  |</a>  *
<a name="line504">504  |</a>  * Returns a pointer to the found value, or NULL if we came up empty.
<a name="line505">505  |</a>  +*/
<a name="line506">506  |</a> /*
<a name="line507">507  |</a>  * Future Ideas:  it'd be nice to move path to a string and implement support for
<a name="line508">508  |</a>  * a teeny tiny micro language here, so you can extract array elements, do things
<a name="line509">509  |</a>  * like .first and .last, even .length.  Inspiration from JSONPath and css selectors?
<a name="line510">510  |</a>  * No it wouldn't be fast, but that's not what this API is about.
<a name="line511">511  |</a>  */
<a name="line512">512  |</a> yajl_val yajl_tree_get(yajl_val n,      /*+ the node under which you'd like to extract values. +*/
<a name="line513">513  |</a>                        const char ** path, /*+ A null terminated array of strings, each the name of an object key +*/
<a name="line514">514  |</a>                        yajl_type type)     /*+ the yajl_type of the object you seek, or yajl_t_any if any will do. +*/
<a name="line515">515  |</a> {
<a name="line516">516  |</a>     if (!path) return NULL;
<a name="line517">517  |</a>     while (n &amp;&amp; *path) {
<a name="line518">518  |</a>         size_t i;
<a name="line519">519  |</a>         size_t len;
<a name="line520">520  |</a> 
<a name="line521">521  |</a>         if (n-&gt;type != yajl_t_object) return NULL;
<a name="line522">522  |</a>         len = n-&gt;u.object.len;
<a name="line523">523  |</a>         for (i = 0; i &lt; len; i++) {
<a name="line524">524  |</a>             if (!strcmp(*path, n-&gt;u.object.keys[i])) {
<a name="line525">525  |</a>                 n = n-&gt;u.object.values[i];
<a name="line526">526  |</a>                 break;
<a name="line527">527  |</a>             }
<a name="line528">528  |</a>         }
<a name="line529">529  |</a>         if (i == len) return NULL;
<a name="line530">530  |</a>         path++;
<a name="line531">531  |</a>     }
<a name="line532">532  |</a>     if (n &amp;&amp; type != yajl_t_any &amp;&amp; type != n-&gt;type) n = NULL;
<a name="line533">533  |</a>     return n;
<a name="line534">534  |</a> }
<a name="line535">535  |</a> 
<a name="line536">536  |</a> /*+
<a name="line537">537  |</a>  * Free a parse tree returned by yajl_tree_parse().
<a name="line538">538  |</a>  +*/
<a name="line539">539  |</a> void yajl_tree_free (yajl_val v)        /*+ Pointer to a JSON value returned by
<a name="line540">540  |</a>                                          * "yajl_tree_parse".  Passing NULL is
<a name="line541">541  |</a>                                          * valid and results in a no-op. +*/
<a name="line542">542  |</a> {
<a name="line543">543  |</a>     if (v == NULL) return;
<a name="line544">544  |</a> 
<a name="line545">545  |</a>     if (YAJL_IS_STRING(v))
<a name="line546">546  |</a>     {
<a name="line547">547  |</a>         free(v-&gt;u.string);
<a name="line548">548  |</a>         free(v);
<a name="line549">549  |</a>     }
<a name="line550">550  |</a>     else if (YAJL_IS_NUMBER(v))
<a name="line551">551  |</a>     {
<a name="line552">552  |</a>         free(v-&gt;u.number.r);
<a name="line553">553  |</a>         free(v);
<a name="line554">554  |</a>     }
<a name="line555">555  |</a>     else if (YAJL_GET_OBJECT(v))
<a name="line556">556  |</a>     {
<a name="line557">557  |</a>         yajl_object_free(v);
<a name="line558">558  |</a>     }
<a name="line559">559  |</a>     else if (YAJL_GET_ARRAY(v))
<a name="line560">560  |</a>     {
<a name="line561">561  |</a>         yajl_array_free(v);
<a name="line562">562  |</a>     }
<a name="line563">563  |</a>     else /* if (yajl_t_true or yajl_t_false or yajl_t_null) */
<a name="line564">564  |</a>     {
<a name="line565">565  |</a>         free(v);
<a name="line566">566  |</a>     }
<a name="line567">567  |</a> }
</pre>

</BODY>
</HTML>
