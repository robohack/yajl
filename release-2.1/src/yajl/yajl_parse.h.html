<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<!-- This HTML file generated by cxref (version 1.6d). -->
<!-- cxref program (c) Andrew M. Bishop 1995-2011. -->

<!--
Cxref: cxref -warn-all -xref-all -block-comments -O/work/woods/f-yajl/build/work/woods/f-yajl/doc/html -Nyajl -html -html-src -I/work/woods/f-yajl/src -I/work/woods/f-yajl/build/work/woods/f-yajl/./src-CPP "cc -E -CC -x c" src/yajl/yajl_parse.h
CPP  : cc -E -CC -x c -Isrc -Ibuild/work/woods/f-yajl/./src
-->

<HTML>

<HEAD>
<TITLE>Cross reference for src/yajl/yajl_parse.h of yajl.</TITLE>
<LINK rel="stylesheet" href="../../cxref.css" type="text/css">
</HEAD>

<BODY>

<h1><a name="file" href="../../src/yajl/yajl_parse.h.src.html">File src/yajl/yajl_parse.h</a></h1>
<span class="cxref-file-comment"> Interface to YAJL's JSON stream parsing facilities.</span>
<p>
<table>
  <tr>
    <td>Included in:
    <td><a href="../../reformatter/json_reformat.c.html#file">reformatter/json_reformat.c</a>
  </tr>
  <tr>
    <td>&nbsp;
    <td><a href="../../src/yajl.c.html#file">src/yajl.c</a>
  </tr>
  <tr>
    <td>&nbsp;
    <td><a href="../../src/yajl_parser.c.html#file">src/yajl_parser.c</a>
  </tr>
  <tr>
    <td>&nbsp;
    <td><a href="../../src/yajl_parser.h.html#file">src/yajl_parser.h</a>
  </tr>
  <tr>
    <td>&nbsp;
    <td><a href="../../src/yajl_tree.c.html#file">src/yajl_tree.c</a>
  </tr>
</table>

<hr>
<h2>Included Files</h2>

<ul class="cxref-include">
  <li class="cxref-include-local"><tt><span class="cxref-include-local"><a href="../../src/yajl/yajl_common.h.html#file">#include "src/yajl/yajl_common.h"</a></span></tt>
  <ul class="cxref-include">
    <li class="cxref-include-system"><tt><span class="cxref-include-system">#include &lt;/usr/include/stddef.h&gt;</span></tt>
  </ul>
</ul>
<ul class="cxref-include">
  <li class="cxref-include-system"><tt><span class="cxref-include-system">#include &lt;/usr/include/stddef.h&gt;</span></tt>
</ul>

<hr>
<h2><a name="type-yajl_status">Typedef yajl_status</a></h2>
<span class="cxref-type-comment"> error codes returned from this interface </span>
<p>
<tt><span class="cxref-type"><a href="../../src/yajl/yajl_parse.h.src.html#line32">typedef enum {...} yajl_status</a></span></tt><br>
<table>
  <tr>
    <td><tt><span class="cxref-type">enum</span></tt>
    <td>&nbsp;
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;<tt><span class="cxref-type">{</span></tt>
    <td>&nbsp;
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">yajl_status_ok;</span></tt>
    <td><span class="cxref-type-comment"> no error was encountered </span>
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">yajl_status_client_canceled;</span></tt>
    <td><span class="cxref-type-comment"> a client callback returned zero, stopping the parse </span>
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">yajl_status_error;</span></tt>
    <td><span class="cxref-type-comment"> An error occurred during the parse.  Call yajl_get_error for
  more information about the encountered error </span>
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;<tt><span class="cxref-type">}</span></tt>
    <td>&nbsp;
  </tr>
</table>

<hr>
<h2><a name="type-yajl_handle">Typedef yajl_handle</a></h2>
<span class="cxref-type-comment"> an opaque handle to a parser </span>
<p>
<tt><span class="cxref-type"><a href="../../src/yajl/yajl_parse.h.src.html#line46">typedef struct yajl_handle_t* yajl_handle</a></span></tt><br>

<hr>
<h2><a name="type-yajl_callbacks">Typedef yajl_callbacks</a></h2>
<span class="cxref-type-comment"> yajl is an event driven parser.  this means as json elements are
  parsed, you are called back to do something with the data.  The
  functions in this table indicate the various events for which
  you will be called back.  Each callback accepts a "context"
  pointer, this is a void * that is passed into the yajl_parse
  function which the client code may use to pass around context.
<br>
  All callbacks return an integer.  If non-zero, the parse will
  continue.  If zero, the parse will be canceled and
  yajl_status_client_canceled will be returned from the parse.
<br>
  \attention {
    A note about the handling of numbers:
<br>
    yajl will only convert numbers that can be represented in a
    double or a 64 bit (long long) int.  All other numbers will
    be passed to the client in string form using the yajl_number
    callback.  Furthermore, if yajl_number is not NULL, it will
    always be used to return numbers, that is yajl_integer and
    yajl_double will be ignored.  If yajl_number is NULL but one
    of yajl_integer or yajl_double are defined, parsing of a
    number larger than is representable in a double or 64 bit
    integer will result in a parse error.
  }</span>
<p>
<tt><span class="cxref-type"><a href="../../src/yajl/yajl_parse.h.src.html#line73">typedef struct {...} yajl_callbacks</a></span></tt><br>
<table>
  <tr>
    <td><tt><span class="cxref-type">struct</span></tt>
    <td>&nbsp;
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;<tt><span class="cxref-type">{</span></tt>
    <td>&nbsp;
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">int (*yajl_null)(void* ctx);</span></tt>
    <td>&nbsp;
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">int (*yajl_boolean)(void* ctx,int boolVal);</span></tt>
    <td>&nbsp;
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">int (*yajl_integer)(void* ctx,long long integerVal);</span></tt>
    <td>&nbsp;
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">int (*yajl_double)(void* ctx,double doubleVal);</span></tt>
    <td>&nbsp;
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">int (*yajl_number)(void* ctx,const char* numberVal,size_t numberLen);</span></tt>
    <td><span class="cxref-type-comment"> A callback which passes the string representation of the number
  back to the client.  Will be used for all numbers when present </span>
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">int (*yajl_string)(void* ctx,const unsigned char* stringVal,size_t stringLen);</span></tt>
    <td><span class="cxref-type-comment"> strings are returned as pointers into the JSON text when,
 possible, as a result, they are _not_ null padded </span>
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">int (*yajl_start_map)(void* ctx);</span></tt>
    <td>&nbsp;
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">int (*yajl_map_key)(void* ctx,const unsigned char* key,size_t stringLen);</span></tt>
    <td>&nbsp;
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">int (*yajl_end_map)(void* ctx);</span></tt>
    <td>&nbsp;
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">int (*yajl_start_array)(void* ctx);</span></tt>
    <td>&nbsp;
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">int (*yajl_end_array)(void* ctx);</span></tt>
    <td>&nbsp;
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;<tt><span class="cxref-type">}</span></tt>
    <td>&nbsp;
  </tr>
</table>

<hr>
<h2><a name="type-yajl_option">Typedef yajl_option</a></h2>
<span class="cxref-type-comment"> configuration parameters for the parser, these may be passed to
  yajl_config() along with option specific argument(s).  In general,
  all configuration parameters default to *off*. </span>
<p>
<tt><span class="cxref-type"><a href="../../src/yajl/yajl_parse.h.src.html#line105">typedef enum {...} yajl_option</a></span></tt><br>
<table>
  <tr>
    <td><tt><span class="cxref-type">enum</span></tt>
    <td>&nbsp;
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;<tt><span class="cxref-type">{</span></tt>
    <td>&nbsp;
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">yajl_allow_comments;</span></tt>
    <td><span class="cxref-type-comment"> Ignore javascript style comments present in
  JSON input.  Non-standard, but rather fun
  arguments: toggled off with integer zero, on otherwise.
<br>
  example:
    yajl_config(h, yajl_allow_comments, 1); // turn comment support on</span>
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">yajl_dont_validate_strings;</span></tt>
    <td><span class="cxref-type-comment"> When set the parser will verify that all strings in JSON input are
 valid UTF8 and will emit a parse error if this is not so.  When set,
 this option makes parsing slightly more expensive (~7% depending
 on processor and compiler in use)
<br>
 example:
   yajl_config(h, yajl_dont_validate_strings, 1); // disable utf8 checking</span>
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">yajl_allow_trailing_garbage;</span></tt>
    <td><span class="cxref-type-comment"> By default, upon calls to yajl_complete_parse(), yajl will
 ensure the entire input text was consumed and will raise an error
 otherwise.  Enabling this flag will cause yajl to disable this
 check.  This can be useful when parsing json out of a that contains more
 than a single JSON document.</span>
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">yajl_allow_multiple_values;</span></tt>
    <td><span class="cxref-type-comment"> Allow multiple values to be parsed by a single handle.  The
 entire text must be valid JSON, and values can be seperated
 by any kind of whitespace.  This flag will change the
 behavior of the parser, and cause it continue parsing after
 a value is parsed, rather than transitioning into a
 complete state.  This option can be useful when parsing multiple
 values from an input stream.</span>
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt><span class="cxref-type">yajl_allow_partial_values;</span></tt>
    <td><span class="cxref-type-comment"> When yajl_complete_parse() is called the parser will
 check that the top level value was completely consumed.  I.E.,
 if called whilst in the middle of parsing a value
 yajl will enter an error state (premature EOF).  Setting this
 flag suppresses that check and the corresponding error.</span>
  </tr>
  <tr>
    <td>&nbsp;&nbsp;&nbsp;<tt><span class="cxref-type">}</span></tt>
    <td>&nbsp;
  </tr>
</table>

</BODY>
</HTML>
